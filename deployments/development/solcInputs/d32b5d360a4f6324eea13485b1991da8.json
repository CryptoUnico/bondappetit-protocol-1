{
  "language": "Solidity",
  "sources": {
    "contracts/ABT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract ABT is ERC20, Ownable {\n    /**\n     * @param initialSupply Total supply.\n     */\n    constructor(uint256 initialSupply) public ERC20(\"Appetit Bond Token\", \"ABT\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    /**\n     * @param account Recipient of created token.\n     * @param amount Amount of token to be created.\n     */\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    /**\n     * @param account Owner of removed token.\n     * @param amount Amount of token to be removed.\n     */\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./Bond.sol\";\nimport \"./ABT.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./uniswap/IUniswapAnchoredView.sol\";\n\ncontract Market is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    uint256 public constant PRICE_DECIMALS = 6;\n\n    /// @notice Address of cumulative token.\n    ERC20 public cumulative;\n\n    /// @notice Address of ABT token contract.\n    ABT public abt;\n\n    /// @notice Address of Bond token contract.\n    Bond public bond;\n\n    /// @notice Price Bond token\n    uint256 public bondPrice = 1000000;\n\n    /// @dev Address of UniswapV2Router.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @dev Address of IUniswapAnchoredView.\n    IUniswapAnchoredView public priceOracle;\n\n    /// @dev Allowed tokens symbols list.\n    mapping(address => string) internal allowedTokens;\n\n    /// @notice An event thats emitted when an price oracle contract address changed.\n    event PriceOracleChanged(address newPriceOracle);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an cumulative token changed.\n    event CumulativeChanged(address newToken);\n\n    /// @notice An event thats emitted when an token allowed.\n    event TokenAllowed(address token, string symbol);\n\n    /// @notice An event thats emitted when an token denied.\n    event TokenDenied(address token);\n\n    /// @notice An event thats emitted when an bond token price changed.\n    event BondPriceChanged(uint256 newPrice);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address customer, address product, address token, uint256 amount, uint256 buy);\n\n    /// @notice An event thats emitted when an cumulative token withdrawal.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token.\n     * @param _abt Address of ABT token.\n     * @param _bond Address of Bond token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     * @param _priceOracle Address of Price oracle contract.\n     */\n    constructor(\n        address _cumulative,\n        address _abt,\n        address _bond,\n        address _uniswapRouter,\n        address _priceOracle\n    ) public {\n        cumulative = ERC20(_cumulative);\n        abt = ABT(_abt);\n        bond = Bond(_bond);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        priceOracle = IUniswapAnchoredView(_priceOracle);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed price oracle contract address.\n     * @param _priceOracle Address new price oracle contract.\n     */\n    function changePriceOracle(address _priceOracle) external onlyOwner {\n        priceOracle = IUniswapAnchoredView(_priceOracle);\n        emit PriceOracleChanged(_priceOracle);\n    }\n\n    /**\n     * @notice Changed cumulative token address.\n     * @param newToken Address new cumulative token.\n     * @param recipient Address of recipient for withdraw current cumulative balance.\n     */\n    function changeCumulativeToken(address newToken, address recipient) external onlyOwner {\n        withdraw(recipient);\n        cumulative = ERC20(newToken);\n        emit CumulativeChanged(newToken);\n    }\n\n    /**\n     * @notice Add token to tokens white list.\n     * @param token Allowable token.\n     */\n    function allowToken(address token, string calldata symbol) external onlyOwner {\n        allowedTokens[token] = symbol;\n        emit TokenAllowed(token, symbol);\n    }\n\n    /**\n     * @notice Remove token from tokens white list.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        allowedTokens[token] = \"\";\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @param token Target token.\n     * @return Is target token allowed.\n     */\n    function isAllowedToken(address token) public view returns (bool) {\n        return bytes(allowedTokens[token]).length != 0;\n    }\n\n    /**\n     * @notice Update Bond token price\n     * @param newPrice New price of Bond token of USD (6 decimal)\n     */\n    function changeBondPrice(uint256 newPrice) external onlyOwner {\n        require(newPrice > 0, \"Market::changeBondPrice: invalid new bond price\");\n\n        bondPrice = newPrice;\n        emit BondPriceChanged(newPrice);\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param from Address of transfered token contract.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transfer(\n        ERC20 from,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(recipient != address(0), \"Market::transfer: cannot transfer to the zero address\");\n\n        uint256 currentBalance = from.balanceOf(address(this));\n        require(amount <= currentBalance, \"Market::transfer: not enough tokens\");\n\n        from.transfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer ABT token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferABT(address recipient, uint256 amount) external onlyOwner {\n        transfer(ERC20(address(abt)), recipient, amount);\n    }\n\n    /**\n     * @notice Transfer Bond token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferBond(address recipient, uint256 amount) external onlyOwner {\n        transfer(ERC20(address(bond)), recipient, amount);\n    }\n\n    /**\n     * @dev Convert token amount to Bond token amount.\n     * @param amount Target token amount.\n     * @return Bond token amount.\n     */\n    function _bondPrice(uint256 amount) internal view returns (uint256) {\n        return amount.mul(10**PRICE_DECIMALS).div(bondPrice);\n    }\n\n    /**\n     * @dev Get product token price from payment token amount.\n     * @param product Product token.\n     * @param token Payment token.\n     * @param amount Payment token amount.\n     * @return Price of product token.\n     */\n    function price(\n        ERC20 product,\n        ERC20 token,\n        uint256 amount\n    ) internal view returns (uint256) {\n        require(isAllowedToken(address(token)), \"Market::price: invalid token\");\n\n        uint256 tokenDecimals = token.decimals();\n        uint256 productDecimals = product.decimals();\n        uint256 tokenPrice = priceOracle.price(allowedTokens[address(token)]);\n        uint256 cumulativePrice = priceOracle.price(cumulative.symbol());\n\n        uint256 result = amount.mul(10**productDecimals.sub(tokenDecimals));\n        if (address(product) != address(token)) {\n            result = tokenPrice.mul(10**PRICE_DECIMALS).div(cumulativePrice).mul(amount).div(10**PRICE_DECIMALS).mul(10**productDecimals.sub(tokenDecimals));\n        }\n        if (address(product) == address(bond)) {\n            return _bondPrice(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Get ABT token price from payment token amount.\n     * @param token Payment token.\n     * @param amount Payment token amount.\n     * @return Price of product token.\n     */\n    function priceABT(address token, uint256 amount) external view returns (uint256) {\n        return price(ERC20(address(abt)), ERC20(token), amount);\n    }\n\n    /**\n     * @dev Get Bond token price from payment token amount.\n     * @param token Payment token.\n     * @param amount Payment token amount.\n     * @return Price of product token.\n     */\n    function priceBond(address token, uint256 amount) external view returns (uint256) {\n        return price(ERC20(address(bond)), ERC20(token), amount);\n    }\n\n    /**\n     * @param token Buy token.\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address token) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == token) {\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = token;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param token Buy token.\n     * @param amount Buy amount.\n     * @return Amount cumulative token after swap.\n     */\n    function _amountOut(address token, uint256 amount) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amount, _path(token));\n        require(amountsOut.length != 0, \"Market::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @dev Buy product token with ERC20 payment token amount.\n     * @param product Purchased token.\n     * @param token Payment token.\n     * @param amount Amount of payment token.\n     * @return True if success.\n     */\n    function buy(\n        ERC20 product,\n        ERC20 token,\n        uint256 amount\n    ) internal whenNotPaused returns (bool) {\n        require(isAllowedToken(address(token)), \"Market::buy: invalid token\");\n\n        uint256 reward = price(product, token, amount);\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        if (address(token) != address(cumulative)) {\n            uint256 amountOut = _amountOut(address(token), amount);\n            require(amountOut != 0, \"Market::buy: liquidity pool is empty\");\n\n            token.safeApprove(address(uniswapRouter), amount);\n            uniswapRouter.swapExactTokensForTokens(amount, amountOut, _path(address(token)), address(this), block.timestamp);\n        }\n\n        product.transfer(msg.sender, reward);\n        emit Buy(msg.sender, address(product), address(token), amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Buy ABT token with ERC20 payment token amount.\n     * @param token Payment token.\n     * @param amount Amount of payment token.\n     * @return True if success.\n     */\n    function buyABT(address token, uint256 amount) external returns (bool) {\n        return buy(ERC20(address(abt)), ERC20(token), amount);\n    }\n\n    /**\n     * @notice Buy Bond token with ERC20 payment token amount.\n     * @param token Payment token.\n     * @param amount Amount of payment token.\n     * @return True if success.\n     */\n    function buyBond(address token, uint256 amount) external returns (bool) {\n        require(bond.balanceOf(msg.sender) > 0, \"Market::buyBond: only tokenholder can buy new bond tokens\");\n\n        return buy(ERC20(address(bond)), ERC20(token), amount);\n    }\n\n    /**\n     * @dev Buy product token with ETH amount.\n     * @param product Purchased token.\n     * @return True if success.\n     */\n    function buyFromETH(ERC20 product) internal whenNotPaused returns (bool) {\n        ERC20 token = ERC20(uniswapRouter.WETH());\n        uint256 amount = msg.value;\n        require(isAllowedToken(address(token)), \"Market::buyFromETH: invalid token\");\n\n        uint256 reward = price(product, token, amount);\n\n        if (address(token) != address(cumulative)) {\n            uint256 amountOut = _amountOut(address(token), amount);\n            require(amountOut != 0, \"Market::buyFromETH: liquidity pool is empty\");\n\n            uniswapRouter.swapExactETHForTokens{value: amount}(amountOut, _path(address(token)), address(this), block.timestamp);\n        }\n\n        product.transfer(msg.sender, reward);\n        emit Buy(msg.sender, address(product), address(token), amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Buy ABT token with ETH amount.\n     * @return True if success.\n     */\n    function buyABTFromETH() external payable returns (bool) {\n        return buyFromETH(ERC20(address(abt)));\n    }\n\n    /**\n     * @notice Buy Bond token with ETH amount.\n     * @return True if success.\n     */\n    function buyBondFromETH() external payable returns (bool) {\n        require(bond.balanceOf(msg.sender) > 0, \"Market::buyBondFromETH: only tokenholder can buy new bond tokens\");\n\n        return buyFromETH(ERC20(address(bond)));\n    }\n\n    /**\n     * @notice Withdraw cumulative token to address.\n     * @param recipient Recipient of token.\n     */\n    function withdraw(address recipient) public onlyOwner {\n        require(recipient != address(0), \"Market::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/utils/OwnablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ncontract OwnablePausable is Ownable, Pausable {\n    /// @notice Address that can pause a contract.\n    address public pauser;\n\n    /// @notice An event thats emitted when an pauser address changed.\n    event PauserChanged(address newPauser);\n\n    constructor() internal {\n        pauser = owner();\n    }\n\n    /**\n     * @notice Change pauser account.\n     * @param newPauser Address of new pauser account.\n     */\n    function changePauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n        emit PauserChanged(pauser);\n    }\n\n    /**\n     * @notice Triggers stopped state.\n     */\n    function pause() public virtual {\n        require(pauser == _msgSender() || owner() == _msgSender(), \"OwnablePausable::pause: only pauser and owner must pause contract\");\n        _pause();\n    }\n\n    /**\n     * @notice Returns to normal state.\n     */\n    function unpause() public virtual {\n        require(pauser == _msgSender() || owner() == _msgSender(), \"OwnablePausable::unpause: only pauser and owner must unpause contract\");\n        _unpause();\n    }\n}\n"
    },
    "contracts/Bond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ncontract Bond is IERC20, Ownable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice EIP-20 token name for this token\n    string public name = \"Bond\";\n\n    /// @notice EIP-20 token symbol for this token\n    string public symbol = \"BOND\";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint256 public override totalSupply = 10000000e18; // 10 million Bond\n\n    /// @dev Allowance amounts on behalf of others\n    mapping(address => mapping(address => uint96)) internal allowances;\n\n    /// @dev Official record of token balances for each account\n    mapping(address => uint96) internal balances;\n\n    /// @notice Amount of blocked token\n    struct Lock {\n        uint96 amount;\n        uint256 date;\n    }\n\n    /// @notice Locking amounts\n    mapping(address => Lock) public locking;\n\n    /// @dev Locking amounts\n    EnumerableSet.AddressSet internal lockingAllowed;\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint256) public nonces;\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account's vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new Bond token\n     * @param account The initial account to grant all the tokens\n     */\n    constructor(address account) public {\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external override view returns (uint256) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 rawAmount) external override returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, \"Bond::approve: amount exceeds 96 bits\");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external override view returns (uint256) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 rawAmount) external override returns (bool) {\n        uint96 amount = safe96(rawAmount, \"Bond::transfer: amount exceeds 96 bits\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 rawAmount\n    ) external override returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, \"Bond::approve: amount exceeds 96 bits\");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance = sub96(spenderAllowance, amount, \"Bond::transferFrom: transfer amount exceeds spender allowance\");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n\n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Add account to transfer lock method allowed list\n     * @param account Allowable account\n     */\n    function allowTransferLock(address account) external onlyOwner returns (bool) {\n        return lockingAllowed.add(account);\n    }\n\n    /**\n     * @notice Remove account from transfer lock method allowed list\n     * @param account Denied account\n     */\n    function denyTransferLock(address account) external onlyOwner returns (bool) {\n        return lockingAllowed.remove(account);\n    }\n\n    function transferLock(address dst, uint256 rawAmount, uint256 date) external returns (bool) {\n        require(lockingAllowed.contains(msg.sender), \"Bond::transferLock: access is denied\");\n        require(locking[dst].date == 0 || locking[dst].date == date, \"Bond::transferLock: lock date cannot be changed\");\n        uint96 amount = safe96(rawAmount, \"Bond::transferLock: amount exceeds 96 bits\");\n\n        locking[dst].date = date;\n        locking[dst].amount = add96(locking[dst].amount, amount, \"Bond::transferLock: transfer amount overflows\");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     * \n     * @param account Recipient of created token.\n     * @param amount Amount of token to be created.\n     */\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n\n    /**\n     * @param account Owner of removed token.\n     * @param amount Amount of token to be removed.\n     */\n    function burn(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"Bond::delegateBySig: invalid signature\");\n        require(nonce == nonces[signatory]++, \"Bond::delegateBySig: invalid nonce\");\n        require(now <= expiry, \"Bond::delegateBySig: signature expired\");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint256 blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, \"Bond::getPriorVotes: not yet determined\");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(\n        address src,\n        address dst,\n        uint96 amount\n    ) internal {\n        require(src != address(0), \"Bond::_transferTokens: cannot transfer from the zero address\");\n        require(dst != address(0), \"Bond::_transferTokens: cannot transfer to the zero address\");\n\n        balances[src] = sub96(balances[src], amount, \"Bond::_transferTokens: transfer amount exceeds balance\");\n        if (locking[src].date > block.timestamp && locking[src].amount > 0 && balances[src] < locking[src].amount) {\n            revert(\"Bond::_transferTokens: amount are locked\");\n        }\n        balances[dst] = add96(balances[dst], amount, \"Bond::_transferTokens: transfer amount overflows\");\n        emit Transfer(src, dst, amount);\n\n        //_moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(\n        address srcRep,\n        address dstRep,\n        uint96 amount\n    ) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, \"Bond::_moveVotes: vote amount underflows\");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, \"Bond::_moveVotes: vote amount overflows\");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        address delegatee,\n        uint32 nCheckpoints,\n        uint96 oldVotes,\n        uint96 newVotes\n    ) internal {\n        uint32 blockNumber = safe32(block.number, \"Bond::_writeCheckpoint: block number exceeds 32 bits\");\n\n        if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n            checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n        } else {\n            checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n            numCheckpoints[delegatee] = nCheckpoints + 1;\n        }\n\n        emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 rawAmount) internal virtual {\n        require(account != address(0), \"Bond::_mint: mint to the zero address\");\n        uint96 amount = safe96(rawAmount, \"Bond::_mint: amount exceeds 96 bits\");\n\n        totalSupply = totalSupply.add(rawAmount);\n        balances[account] = add96(balances[account], amount, \"Bond::_mint: mint amount overflows\");\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 rawAmount) internal virtual {\n        require(account != address(0), \"Bond::_burn: burn from the zero address\");\n        uint96 amount = safe96(rawAmount, \"Bond::_burn: amount exceeds 96 bits\");\n\n        balances[account] = sub96(balances[account], amount, \"ERC20: burn amount exceeds balance\");\n        totalSupply = totalSupply.sub(rawAmount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint256 n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(\n        uint96 a,\n        uint96 b,\n        string memory errorMessage\n    ) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n"
    },
    "contracts/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/uniswap/IUniswapAnchoredView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapAnchoredView {\n    function price(string calldata symbol) external view returns (uint);\n}"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/profit/UniswapMarketMaker.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\nimport \"../uniswap/IUniswapV2Factory.sol\";\n\ncontract UniswapMarketMaker is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Support token.\n    ERC20 public support;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an token transferred to recipient.\n    event Transfer(address token, address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an liquidity added.\n    event LiquidityAdded(uint256 incoming, uint256 support);\n\n    /// @notice An event thats emitted when an liquidity removed.\n    event LiquidityRemoved(uint256 lp, uint256 incoming, uint256 support);\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _support Address of support token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _incoming,\n        address _support,\n        address _uniswapRouter\n    ) public {\n        incoming = ERC20(_incoming);\n        support = ERC20(_support);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param token Address of transferred token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner {\n        require(recipient != address(0), \"UniswapMarketMaker::transfer: cannot transfer to the zero address\");\n\n        ERC20(token).safeTransfer(recipient, amount);\n        emit Transfer(token, recipient, amount);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"UniswapMarketMaker::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            incoming.safeTransfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @notice Buy support token and add liquidity.\n     * @param amount Amount of incoming token.\n     */\n    function buyLiquidity(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(incoming);\n        path[1] = address(support);\n\n        uint256 amountIn = incoming.balanceOf(address(this)).div(2);\n        require(amountIn > 0, \"UniswapMarketMaker::buyLiquidity: not enough funds to buy back\");\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\n        require(amountsOut.length != 0, \"UniswapMarketMaker::buyLiquidity: invalid amounts out length\");\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        require(amountOut > 0, \"UniswapMarketMaker::buyLiquidity: liquidity pool is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), amountIn);\n        uniswapRouter.swapExactTokensForTokens(amountIn, amountOut, path, address(this), block.timestamp);\n\n        uint256 incomingBalance = incoming.balanceOf(address(this));\n        require(incomingBalance > 0, \"UniswapMarketMaker::buyLiquidity: incoming token balance is empty\");\n        uint256 supportBalance = support.balanceOf(address(this));\n        require(supportBalance > 0, \"UniswapMarketMaker::buyLiquidity: support token balance is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), incomingBalance);\n        support.safeApprove(address(uniswapRouter), supportBalance);\n        (uint256 amountA, uint256 amountB, ) = uniswapRouter.addLiquidity(address(incoming), address(support), incomingBalance, supportBalance, 0, 0, address(this), block.timestamp);\n        emit LiquidityAdded(amountA, amountB);\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        support.safeApprove(address(uniswapRouter), 0);\n    }\n\n    /**\n     * @notice Add liquidity.\n     * @param incomingAmount Amount of incoming token.\n     * @param supportAmount Amount of support token.\n     */\n    function addLiquidity(uint256 incomingAmount, uint256 supportAmount) external whenNotPaused {\n        if (incomingAmount > 0) {\n            incoming.safeTransferFrom(msg.sender, address(this), incomingAmount);\n        }\n        if (supportAmount > 0) {\n            support.safeTransferFrom(msg.sender, address(this), supportAmount);\n        }\n\n        uint256 incomingBalance = incoming.balanceOf(address(this));\n        require(incomingBalance > 0, \"UniswapMarketMaker::addLiquidity: incoming token balance is empty\");\n        uint256 supportBalance = support.balanceOf(address(this));\n        require(supportBalance > 0, \"UniswapMarketMaker::addLiquidity: support token balance is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), incomingBalance);\n        support.safeApprove(address(uniswapRouter), supportBalance);\n        (uint256 amountA, uint256 amountB, ) = uniswapRouter.addLiquidity(address(incoming), address(support), incomingBalance, supportBalance, 0, 0, address(this), block.timestamp);\n        emit LiquidityAdded(amountA, amountB);\n\n        incoming.safeApprove(address(uniswapRouter), 0);\n        support.safeApprove(address(uniswapRouter), 0);\n    }\n\n    /**\n     * @notice Return liquidity pair address.\n     * @return Liquidity pair address.\n     */\n    function liquidityPair() public view returns (address) {\n        IUniswapV2Factory uniswapFactory = IUniswapV2Factory(uniswapRouter.factory());\n        return uniswapFactory.getPair(address(incoming), address(support));\n    }\n\n    /**\n     * @notice Remove liquidity.\n     * @param amount Amount of liquidity pool token.\n     */\n    function removeLiquidity(uint256 amount) external onlyOwner {\n        address pair = liquidityPair();\n        require(pair != address(0), \"UniswapMarketMaker::removeLiquidity: liquidity pair not found\");\n\n        uint256 lpBalance = ERC20(pair).balanceOf(address(this));\n        amount = lpBalance < amount ? lpBalance : amount;\n        require(amount > 0, \"UniswapMarketMaker::removeLiquidity: zero amount\");\n\n        ERC20(pair).safeApprove(address(uniswapRouter), amount);\n        (uint256 incomingAmount, uint256 supportAmount) = uniswapRouter.removeLiquidity(address(incoming), address(support), amount, 0, 0, address(this), block.timestamp);\n        emit LiquidityRemoved(amount, incomingAmount, supportAmount);\n    }\n}\n"
    },
    "contracts/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/Vesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./Bond.sol\";\n\ncontract Vesting is OwnablePausable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice The number of periods for a per recipient.\n    function maxPeriodsPerRecipient() public pure returns (uint256) {\n        return 5;\n    } // 5 perios per recipient.\n\n    /// @notice Address of Bond token.\n    Bond public bond;\n\n    struct Period {\n        // Identifier.\n        uint256 id;\n        // Reward amount.\n        uint256 amount;\n        // Unlockd date.\n        uint256 date;\n        // Reward withdrawal flag.\n        bool withdrawal;\n    }\n\n    /// @dev Index last period.\n    uint256 internal currentPeriod = 0;\n\n    /// @dev Participants list.\n    EnumerableSet.AddressSet internal participants;\n\n    /// @dev All registered periods.\n    mapping(address => mapping(uint256 => Period)) internal periods;\n\n    /// @dev Period identifiers index.\n    mapping(address => uint256[]) internal periodsIndex;\n\n    /// @notice An event emitted when locking a period.\n    event Locked(uint256 periodId);\n\n    /// @notice An event emitted when revoked a period.\n    event Revoked(uint256 periodId);\n\n    /// @notice An event emitted when withdrawal a period.\n    event Withdrawal(address recipient, uint256 periodId);\n\n    /**\n     * @param _bond Address of Bond token contract.\n     */\n    constructor(address _bond) public {\n        bond = Bond(_bond);\n    }\n\n    /**\n     * @notice Add new period.\n     * @param recipient Recipient of reward.\n     * @param amount Reward amount.\n     * @param date Date of unlockd period.\n     * @return Added period identifier.\n     */\n    function lock(\n        address recipient,\n        uint256 amount,\n        uint256 date\n    ) external onlyOwner returns (uint256) {\n        require(periodsIndex[recipient].length < maxPeriodsPerRecipient(), \"Vesting::lock: too many periods\");\n\n        bond.transferFrom(_msgSender(), address(this), amount);\n\n        currentPeriod += 1;\n        participants.add(recipient);\n        periods[recipient][currentPeriod] = Period(currentPeriod, amount, date, false);\n        periodsIndex[recipient].push(currentPeriod);\n        emit Locked(currentPeriod);\n\n        return currentPeriod;\n    }\n\n    /**\n     * @notice Revoke period.\n     * @param recipient Recipient of reward.\n     * @param periodId Period identifier.\n     */\n    function revoke(address recipient, uint256 periodId) external onlyOwner {\n        Period storage period = periods[recipient][periodId];\n        require(!period.withdrawal, \"Vesting::revoke: already withdraw\");\n\n        address owner = _msgSender();\n        uint256 amount = period.amount;\n        period.amount = 0;\n        bond.transfer(owner, amount);\n\n        emit Revoked(periodId);\n    }\n\n    /**\n     * @notice Return all participants addresses.\n     * @return Participants addresses.\n     */\n    function getParticipants() external view returns (address[] memory) {\n        address[] memory result = new address[](participants.length());\n\n        for (uint256 i = 0; i < participants.length(); i++) {\n            result[i] = participants.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Get information of period.\n     * @param recipient Recipient address.\n     * @return Recipient periods list.\n     */\n    function info(address recipient) external view returns (Period[] memory) {\n        Period[] memory result = new Period[](periodsIndex[recipient].length);\n\n        for (uint256 i = 0; i < periodsIndex[recipient].length; i++) {\n            uint256 periodId = periodsIndex[recipient][i];\n\n            result[i] = periods[recipient][periodId];\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Withdraw reward.\n     * @param periodId Target period identifier.\n     */\n    function withdraw(uint256 periodId) external whenNotPaused {\n        address recipient = _msgSender();\n        Period storage period = periods[recipient][periodId];\n        require(period.amount > 0, \"Vesting::withdraw: period is empty\");\n        require(!period.withdrawal, \"Vesting::withdraw: already withdraw\");\n        require(block.timestamp > period.date, \"Vesting::withdraw: access denied\");\n\n        period.withdrawal = true;\n        bond.transfer(recipient, period.amount);\n        emit Withdrawal(recipient, periodId);\n    }\n}\n"
    },
    "contracts/Investment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./Bond.sol\";\n\ncontract Investment is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    ///@notice Address of cumulative token\n    ERC20 public cumulative;\n\n    ///@notice Address of Bond token\n    Bond public bond;\n\n    ///@notice Date of locking bond token\n    uint256 public bondTokenLockDate;\n\n    uint8 internal constant BOND_PRICE_DECIMALS = 6;\n\n    ///@notice Price Bond token\n    uint256 public bondPrice = 1000000;\n\n    ///@dev Address of UniswapV2Router\n    IUniswapV2Router02 internal uniswapRouter;\n\n    ///@notice Investment tokens list\n    mapping(address => bool) public investmentTokens;\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an invest token allowed.\n    event InvestTokenAllowed(address token);\n\n    /// @notice An event thats emitted when an invest token denied.\n    event InvestTokenDenied(address token);\n\n    /// @notice An event thats emitted when an bond price changed.\n    event BondPriceChanged(uint256 newPrice);\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address investor, address token, uint256 amount, uint256 reward);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token\n     * @param _bond Address of Bond token\n     * @param _uniswapRouter Address of UniswapV2Router\n     */\n    constructor(\n        address _cumulative,\n        address _bond,\n        uint256 _bondTokenLockDate,\n        address _uniswapRouter\n    ) public {\n        cumulative = ERC20(_cumulative);\n        bond = Bond(_bond);\n        bondTokenLockDate = _bondTokenLockDate;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Add token to investable tokens white list\n     * @param token Allowable token\n     */\n    function allowToken(address token) external onlyOwner {\n        investmentTokens[token] = true;\n        emit InvestTokenAllowed(token);\n    }\n\n    /**\n     * @notice Remove token from investable tokens white list\n     * @param token Denied token\n     */\n    function denyToken(address token) external onlyOwner {\n        investmentTokens[token] = false;\n        emit InvestTokenDenied(token);\n    }\n\n    /**\n     * @notice Update Bond token price\n     * @param newPrice New price of Bond token of USD (6 decimal)\n     */\n    function changeBondPrice(uint256 newPrice) external onlyOwner {\n        require(newPrice > 0, \"Investment::changeBondPrice: invalid new bond price\");\n\n        bondPrice = newPrice;\n        emit BondPriceChanged(newPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address token) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == token) {\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = token;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount cumulative token after swap\n     */\n    function _amountOut(address token, uint256 amount) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amount, _path(token));\n        require(amountsOut.length != 0, \"Investment::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @param amount Cumulative amount invested\n     * @return Amount bond token after swap\n     */\n    function _bondPrice(uint256 amount) internal view returns (uint256) {\n        uint256 decimals = cumulative.decimals();\n\n        return amount.mul(10**(18 - decimals + BOND_PRICE_DECIMALS)).div(bondPrice);\n    }\n\n    /**\n     * @param token Invested token\n     * @param amount Invested amount\n     * @return Amount bond token after swap\n     */\n    function price(address token, uint256 amount) external view returns (uint256) {\n        require(investmentTokens[token], \"Investment::price: invalid investable token\");\n\n        uint256 amountOut = amount;\n        if (token != address(cumulative)) {\n            amountOut = _amountOut(token, amount);\n        }\n\n        return _bondPrice(amountOut);\n    }\n\n    /**\n     * @notice Invest tokens to protocol\n     * @param token Invested token\n     * @param amount Invested amount\n     */\n    function invest(address token, uint256 amount) external whenNotPaused returns (bool) {\n        require(investmentTokens[token], \"Investment::invest: invalid investable token\");\n        uint256 reward = _bondPrice(amount);\n\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, amount);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _bondPrice(amountOut);\n\n            ERC20(token).safeApprove(address(uniswapRouter), amount);\n            uniswapRouter.swapExactTokensForTokens(amount, amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        bond.transferLock(msg.sender, reward, bondTokenLockDate);\n\n        emit Invested(msg.sender, token, amount, reward);\n        return true;\n    }\n\n    /**\n     * @notice Invest ETH to protocol\n     */\n    function investETH() external payable whenNotPaused returns (bool) {\n        address token = uniswapRouter.WETH();\n        require(investmentTokens[token], \"Investment::investETH: invalid investable token\");\n        uint256 reward = _bondPrice(msg.value);\n\n        if (token != address(cumulative)) {\n            uint256 amountOut = _amountOut(token, msg.value);\n            require(amountOut != 0, \"Investment::invest: liquidity pool is empty\");\n            reward = _bondPrice(amountOut);\n\n            uniswapRouter.swapExactETHForTokens{value: msg.value}(amountOut, _path(token), address(this), block.timestamp);\n        }\n\n        bond.transferLock(msg.sender, reward, bondTokenLockDate);\n\n        emit Invested(msg.sender, token, msg.value, reward);\n        return true;\n    }\n\n    /**\n     * @notice Withdraw invested token to address\n     * @param recipient Recipient of tokens\n     */\n    function withdraw(address recipient) external onlyOwner {\n        require(recipient != address(0), \"Investment::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract Treasury is Ownable {\n    using SafeMath for uint256;\n\n    receive() external payable {}\n\n    /**\n     * @notice Transfer target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        return IERC20(token).transfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer ETH to recipient.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transferETH(address payable recipient, uint256 amount) external onlyOwner returns (bool) {\n        recipient.transfer(amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Approve amount.\n     */\n    function approve(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyOwner returns (bool) {\n        return IERC20(token).approve(recipient, amount);\n    }\n}\n"
    },
    "contracts/Stacking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Stacking is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Address of reward token contract.\n    ERC20 public rewardToken;\n\n    /// @notice Reward configuration.\n    struct Reward {\n        // Current reward per block.\n        uint256 delta;\n\n        // Block number of last change reward.\n        uint256 blockAt;\n\n        // Price of last change reward.\n        uint256 priceAt;\n    }\n\n    /// @notice Reward configuration of locked tokens.\n    mapping(address => Reward) public rewards;\n\n    /// @notice Current blanace of account.\n    struct Balance {\n        // Locked token amount.\n        uint256 amount;\n\n        // Nominal cost of locked token amount.\n        uint256 cost;\n    }\n\n    /// @notice Balances of locked tokens for all accounts.\n    mapping(address => mapping(address => Balance)) public balances;\n\n    /// @notice An event thats emitted when an token reward changed.\n    event RewardChanged(address token, uint256 from, uint256 to);\n\n    /// @notice An event thats emitted when a token is locked by an account.\n    event Locked(address account, address token, uint256 amount);\n\n    /// @notice An event thats emitted when a token is unlocked by an account.\n    event Unlocked(address account, address token);\n\n    /**\n     * @param _rewardToken Address of reward token contract.\n     */\n    constructor(address _rewardToken) public {\n        rewardToken = ERC20(_rewardToken);\n    }\n\n    /**\n     * @notice Change reward token delta.\n     * @param token Changed token address.\n     * @param newDelta New reward delta.\n     */\n    function changeReward(address token, uint256 newDelta) external onlyOwner {\n        Reward storage reward = rewards[token];\n        rewards[token] = Reward(newDelta, block.number.sub(1), price(token).sub(reward.delta));\n        emit RewardChanged(token, reward.delta, newDelta);\n    }\n\n    /**\n     * @notice Get current price of token.\n     * @param token Address of token.\n     * @return Price of token.\n     */\n    function price(address token) public view returns (uint256) {\n        Reward storage reward = rewards[token];\n        return reward.priceAt.add(reward.delta.mul(block.number.sub(reward.blockAt)));\n    }\n\n    /**\n     * @notice Get current reward of token for sender.\n     * @param token Address of token.\n     * @return Reward of token for sender.\n     */\n    function reward(address token) public view returns (uint256) {\n        uint256 decimals = rewardToken.decimals();\n        Balance storage balance = balances[msg.sender][token];\n        return balance.amount.mul(price(token)).sub(balance.cost).div(10**decimals);\n    }\n\n    /**\n     * @notice Stacking token.\n     * @param token Address of stacking token.\n     * @param amount Amount of stacking token.\n     */\n    function lock(address token, uint256 amount) external whenNotPaused {\n        require(amount != 0, \"Stacking::lock: negative amount\");\n\n        ERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        Balance storage balance = balances[msg.sender][token];\n        uint256 newAmount = balance.amount.add(amount);\n        uint256 newCost = balance.cost.add(amount.mul(price(token)));\n        balances[msg.sender][token] = Balance(newAmount, newCost);\n        emit Locked(msg.sender, token, amount);\n    }\n\n    /**\n     * @notice Unstacking token.\n     * @param token Address of unstacking token.\n     */\n    function unlock(address token) external whenNotPaused {\n        Balance memory balance = balances[msg.sender][token];\n        require(balance.amount > 0, \"Stacking::unlock: balance is empty\");\n        uint256 _reward = reward(token);\n\n        balances[msg.sender][token] = Balance(0, 0);\n        ERC20(token).safeTransfer(msg.sender, balance.amount);\n        if (_reward > 0) {\n            rewardToken.safeTransfer(msg.sender, _reward);\n        }\n        emit Unlocked(msg.sender, token);\n    }\n}\n"
    },
    "contracts/profit/ProfitSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract ProfitSplitter is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 public constant SHARE_ACCURACY = 6;\n\n    uint256 public constant SHARE_DIGITS = 2;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Budget contract address.\n    address payable public budget;\n\n    /// @notice Target budget ETH balance.\n    uint256 public budgetBalance;\n\n    /// @notice Recipients share.\n    mapping(address => uint256) public shares;\n\n    /// @dev Recipients addresses index.\n    EnumerableSet.AddressSet private recipientsIndex;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an budget contract address and target balance changed.\n    event BudgetChanged(address newBudget, uint256 newBalance);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an recipient added.\n    event RecipientAdded(address recipient, uint256 share);\n\n    /// @notice An event thats emitted when an recipient removed.\n    event RecipientRemoved(address recipient);\n\n    /// @notice An event thats emitted when an profit payed to budget.\n    event PayToBudget(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an profit payed to recipient.\n    event PayToRecipient(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(address _incoming, address _uniswapRouter) public {\n        incoming = ERC20(_incoming);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed budget contract address and target balance.\n     * @param _budget Address of budget contract.\n     * @param _budgetBalance Target budget balance.\n     */\n    function changeBudget(address payable _budget, uint256 _budgetBalance) external onlyOwner {\n        budget = _budget;\n        budgetBalance = _budgetBalance;\n        emit BudgetChanged(budget, budgetBalance);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"ProfitSplitter::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"ProfitSplitter::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @dev Current share value.\n     * @return result Current share value.\n     */\n    function _currentShare() internal view returns (uint256 result) {\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result = result.add(shares[recipientsIndex.at(i)]);\n        }\n    }\n\n    /**\n     * @notice Add recipient.\n     * @param recipient Address of recipient contract.\n     * @param share Target share.\n     */\n    function addRecipient(address recipient, uint256 share) external onlyOwner {\n        require(!recipientsIndex.contains(recipient), \"ProfitSplitter::addRecipient: recipient already added\");\n        require(_currentShare().add(share) <= 100, \"ProfitSplitter::addRecipient: invalid share\");\n\n        recipientsIndex.add(recipient);\n        shares[recipient] = share;\n        emit RecipientAdded(recipient, share);\n    }\n\n    /**\n     * @notice Remove recipient.\n     * @param recipient Address of recipient contract.\n     */\n    function removeRecipient(address recipient) external onlyOwner {\n        require(recipientsIndex.contains(recipient), \"ProfitSplitter::removeRecipient: recipient already removed\");\n\n        recipientsIndex.remove(recipient);\n        shares[recipient] = 0;\n        emit RecipientRemoved(recipient);\n    }\n\n    /**\n     * @notice Get addresses of recipients.\n     * @return Current recipients list.\n     */\n    function getRecipients() public view returns (address[] memory) {\n        address[] memory result = new address[](recipientsIndex.length());\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            result[i] = recipientsIndex.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Pay ETH to budget contract.\n     */\n    function _payToBudget() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        uint256 currentBudgetBalance = budget.balance;\n        if (currentBudgetBalance >= budgetBalance) return false;\n\n        uint256 amount = budgetBalance.sub(currentBudgetBalance);\n        uint256 splitterEthBalance = address(this).balance;\n        if (splitterEthBalance < amount) {\n            uint256 amountOut = amount.sub(splitterEthBalance);\n\n            address[] memory path = new address[](2);\n            path[0] = address(incoming);\n            path[1] = uniswapRouter.WETH();\n\n            uint256[] memory amountsIn = uniswapRouter.getAmountsIn(amountOut, path);\n            require(amountsIn.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts in length\");\n            require(amountsIn[0] > 0, \"ProfitSplitter::_payToBudget: liquidity pool is empty\");\n            if (amountsIn[0] <= splitterIncomingBalance) {\n                incoming.safeApprove(address(uniswapRouter), amountsIn[0]);\n                uniswapRouter.swapTokensForExactETH(amountOut, amountsIn[0], path, address(this), block.timestamp);\n            } else {\n                uint256[] memory amountsOut = uniswapRouter.getAmountsOut(splitterIncomingBalance, path);\n                require(amountsOut.length == 2, \"ProfitSplitter::_payToBudget: invalid amounts out length\");\n                require(amountsOut[1] > 0, \"ProfitSplitter::_payToBudget: amounts out liquidity pool is empty\");\n\n                amount = amountsOut[1];\n\n                incoming.safeApprove(address(uniswapRouter), splitterIncomingBalance);\n                uniswapRouter.swapExactTokensForETH(splitterIncomingBalance, amountsOut[1], path, address(this), block.timestamp);\n            }\n        }\n\n        budget.transfer(amount);\n        emit PayToBudget(budget, amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Pay incoming token to all recipients.\n     */\n    function _payToRecipients() internal returns (bool) {\n        uint256 splitterIncomingBalance = incoming.balanceOf(address(this));\n        if (splitterIncomingBalance == 0) return false;\n\n        for (uint256 i = 0; i < recipientsIndex.length(); i++) {\n            address recipient = recipientsIndex.at(i);\n            uint256 share = shares[recipient];\n\n            uint256 amount = splitterIncomingBalance.mul(10**SHARE_ACCURACY).mul(share).div(10**SHARE_ACCURACY.add(SHARE_DIGITS));\n            incoming.safeTransfer(recipient, amount);\n\n            emit PayToRecipient(recipient, amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @notice Split all incoming token balance to recipients and budget contract.\n     * @param amount Approved amount incoming token.\n     */\n    function split(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        _payToBudget();\n        _payToRecipients();\n    }\n}\n"
    },
    "contracts/oracle/HighAlertOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../utils/OwnablePausable.sol\";\n\ncontract HighAlertOracle is Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Pausable list.\n    EnumerableSet.AddressSet private contracts;\n\n    /// @notice An event emitted when contract added to pausable list.\n    event ContractAdded(address addedContract);\n\n    /// @notice An event emitted when contract removed at pausable list.\n    event ContractRemoved(address removedContract);\n\n    /// @notice An event emitted when paused all contracts.\n    event PausedAll(string reason);\n\n    /// @notice An event emitted when unpaused all contracts.\n    event UnpausedAll(string reason);\n\n    /**\n     * @notice Add contract to pausable list.\n     * @param _contract Target contract.\n     */\n    function addContract(address _contract) external onlyOwner {\n        contracts.add(_contract);\n        emit ContractAdded(_contract);\n    }\n\n    /**\n     * @notice Remove contract at pausable list.\n     * @param _contract Target contract.\n     */\n    function removeContract(address _contract) external onlyOwner {\n        contracts.add(_contract);\n        emit ContractRemoved(_contract);\n    }\n\n    /**\n     * @notice Return all pausable contracts.\n     * @return Pausable contracts list.\n     */\n    function getContracts() external view returns (address[] memory) {\n        address[] memory result;\n\n        for (uint256 i = 0; i < contracts.length(); i++) {\n            result[i] = contracts.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Pause all pausable contracts.\n     * @param reason Reason of pause.\n     */\n    function _pauseAll(string memory reason) internal {\n        for (uint256 i = 0; i < contracts.length(); i++) {\n            OwnablePausable(contracts.at(i)).pause();\n        }\n        emit PausedAll(reason);\n    }\n\n    /**\n     * @dev Unpause all pausable contracts.\n     * @param reason Reason of unpause.\n     */\n    function _unpauseAll(string memory reason) internal {\n        for (uint256 i = 0; i < contracts.length(); i++) {\n            OwnablePausable(contracts.at(i)).unpause();\n        }\n        emit UnpausedAll(reason);\n    }\n\n    /**\n     * @notice Pause all pausable contracts.\n     * @param reason Reason of pause.\n     */\n    function pauseAll(string calldata reason) external onlyOwner {\n        _pauseAll(reason);\n    }\n\n    /**\n     * @notice Unpause all pausable contracts.\n     * @param reason Reason of unpause.\n     */\n    function unpauseAll(string calldata reason) external onlyOwner {\n        _unpauseAll(reason);\n    }\n}\n"
    },
    "contracts/oracle/SecurityOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./ISecurityOracle.sol\";\n\ncontract SecurityOracle is ISecurityOracle, Ownable {\n    /// @dev Data of security properties.\n    mapping(string => mapping(string => bytes)) private data;\n\n    function put(\n        string calldata isin,\n        string calldata prop,\n        bytes calldata value\n    ) external override onlyOwner {\n        data[isin][prop] = value;\n        emit Update(isin, prop, value);\n    }\n\n    function get(string calldata isin, string calldata prop) external override view returns (bytes memory) {\n        return data[isin][prop];\n    }\n}\n"
    },
    "contracts/oracle/ISecurityOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title The Security Oracle interface.\n */\ninterface ISecurityOracle {\n    /**\n     * @notice Put property value of security.\n     * @param isin International securities identification number of security.\n     * @param prop Property name of security.\n     * @param value Property value.\n     */\n    function put(string calldata isin, string calldata prop, bytes calldata value) external;\n\n    /**\n     * @notice Get property value of security.\n     * @param isin International securities identification number of security.\n     * @param prop Property name of security.\n     * @return Property value of security.\n     */\n    function get(string calldata isin, string calldata prop) external view returns(bytes memory);\n\n    /**\n     * @dev Emitted when the security property update.\n     */\n    event Update(string isin, string prop, bytes value);\n}\n"
    },
    "contracts/oracle/BondDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./IDepositaryOracle.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"./ISecurityOracle.sol\";\n\ncontract BondDepositaryBalanceView is IDepositaryBalanceView {\n    using SafeMath for uint256;\n\n    /// @notice Depositary.\n    IDepositaryOracle public depositary;\n\n    /// @notice Price oracles.\n    ISecurityOracle public securityOracle;\n\n    /// @notice Decimals balance.\n    uint256 override public decimals = 6;\n\n    /**\n     * @param _depositary Depositary address.\n     * @param _securityOracle Security oracle addresses.\n     */\n    constructor(address _depositary, address _securityOracle) public {\n        depositary = IDepositaryOracle(_depositary);\n        securityOracle = ISecurityOracle(_securityOracle);\n    }\n\n    function balance() external override view returns(uint256) {\n        uint256 result;\n\n        IDepositaryOracle.Security[] memory bonds = depositary.all();\n        for (uint256 i = 0; i < bonds.length; i++) {                \n            IDepositaryOracle.Security memory bond = bonds[i];\n            if (bond.amount == 0) continue;\n\n            bytes memory value = securityOracle.get(bond.isin, \"nominalValue\");\n            if (value.length == 0) continue;\n\n            (uint256 nominalValue) = abi.decode(value, (uint256));\n            result = result.add(bond.amount.mul(nominalValue));\n        }\n\n        return result;\n    }\n}"
    },
    "contracts/oracle/IDepositaryOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\n/**\n * @title The Depositary Oracle interface.\n */\ninterface IDepositaryOracle {\n    /// @notice Type of security on depositary.\n    struct Security {\n        // International securities identification number.\n        string isin;\n        // Amount.\n        uint256 amount;\n    }\n\n    /**\n     * @notice Write a security amount to the storage mapping.\n     * @param isin International securities identification number.\n     * @param amount Amount of securities.\n     */\n    function put(string calldata isin, uint256 amount) external;\n\n    /**\n     * @notice Get amount securities.\n     * @param isin International securities identification number.\n     * @return amount Amount of securities.\n     */\n    function get(string calldata isin) external view returns (Security memory);\n\n    /**\n     * @notice Get all depositary securities.\n     * @return All securities.\n     */\n    function all() external view returns (Security[] memory);\n\n    /**\n     * @dev Emitted when the depositary update.\n     */\n    event Update(string isin, uint256 amount);\n}\n"
    },
    "contracts/oracle/IDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title The Depositary Balance interface.\n */\ninterface IDepositaryBalanceView {\n    /**\n     * @notice Get decimals balance.\n     * @return Decimals balance.\n     */\n    function decimals() external view returns(uint256);\n\n    /**\n     * @notice Get balance of depositary.\n     * @return Balance of depositary.\n     */\n    function balance() external view returns(uint256);\n}"
    },
    "contracts/oracle/AgregateDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract AgregateDepositaryBalanceView is IDepositaryBalanceView, OwnablePausable {\n    using SafeMath for uint256;\n\n    /// @notice The number of depositaries in agregate.\n    uint256 public maxSize;\n    \n    /// @notice Decimals balance.\n    uint256 override public decimals;\n\n    /// @notice Depositaries in agregate.\n    IDepositaryBalanceView[] public depositaries;\n\n    /// @dev Depositaries index.\n    mapping(address => uint256) internal depositariesIndex;\n\n    /// @notice An event thats emitted when an new depositary added to agregate.\n    event DepositaryAdded(address depositary);\n    \n    /// @notice An event thats emitted when an depositary removed from agregate.\n    event DepositaryRemoved(address depositary);\n\n    /**\n     * @param _decimals Decimals balance.\n     * @param _maxSize Max number depositaries in agregate.\n     */\n    constructor(uint256 _decimals, uint256 _maxSize) public {\n        decimals = _decimals;\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @return Depositaries count of agregate.\n     */\n    function size() public view returns(uint256) {\n        return depositaries.length;\n    }\n\n    /**\n     * @notice Add depositary address to agregate.\n     * @param depositary Added depositary address.\n     */\n    function addDepositary(address depositary) external onlyOwner {\n        require(depositariesIndex[depositary] == 0, \"AgregateDepositaryBalanceView::addDepositary: depositary already added\");\n        require(size() < maxSize, \"AgregateDepositaryBalanceView::addDepositary: too many depositaries\");\n\n        depositaries.push(IDepositaryBalanceView(depositary));\n        depositariesIndex[depositary] = size().sub(1);\n        emit DepositaryAdded(depositary);\n    }\n\n    /**\n     * @notice Removed depositary address from agregate.\n     * @param depositary Removed depositary address.\n     */\n    function removeDepositary(address depositary) external onlyOwner {\n        uint256 depositaryIndex = depositariesIndex[depositary];\n        require(depositaryIndex != 0, \"AgregateDepositaryBalanceView::removeDepositary: depositary already removed\");\n\n        delete depositariesIndex[depositary];\n        depositaries[depositaryIndex] = depositaries[size().sub(1)];\n        delete depositaries[size().sub(1)];\n        emit DepositaryRemoved(depositary);\n    }\n\n    function balance() external override view returns(uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < size(); i++) {                \n            uint256 depositaryBalance = depositaries[i].balance();\n            uint256 depositaryDecimals = depositaries[i].decimals();\n            uint256 decimalsPower = decimals.sub(depositaryDecimals);\n            result = result.add(depositaryBalance.mul(10**decimalsPower));\n        }\n\n        return result;\n    }\n}"
    },
    "contracts/Issuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./oracle/AgregateDepositaryBalanceView.sol\";\nimport \"./ABT.sol\";\n\ncontract Issuer is AgregateDepositaryBalanceView {\n    using SafeMath for uint256;\n\n    /// @notice ABT contract address.\n    ABT public abt;\n\n    /// @notice Treasury contract address.\n    address public treasury;\n\n    /// @notice An event thats emitted when an Treasury contract transfered.\n    event TransferTreasury(address newTreasury);\n\n    /// @notice An event thats emitted when an ABT total supply rebalanced.\n    event Rebalance();\n\n    /**\n     * @param _abt ABT contract address.\n     * @param _treasury Treasury contract address.\n     */\n    constructor(address _abt, address _treasury) public AgregateDepositaryBalanceView(ABT(_abt).decimals(), 50) {\n        abt = ABT(_abt);\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Transfer Treasury contract to new address.\n     * @param _treasury New address Treasury contract.\n     */\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit TransferTreasury(treasury);\n    }\n\n    /**\n     * @notice Rebalance ABT total supply by depositary balance. Mint ABT tokens if depositary balance greater token total supply and burn otherwise.\n     */\n    function rebalance() external whenNotPaused {\n        uint256 currentDepositaryBalance = this.balance();\n        uint256 burningBalance = abt.balanceOf(address(this));\n        uint256 abtTotalSupply = abt.totalSupply();\n\n        if (abtTotalSupply > currentDepositaryBalance && burningBalance > 0) {\n            abt.burn(address(this), burningBalance);\n            emit Rebalance();\n\n            abtTotalSupply = abt.totalSupply();\n        }\n        if (abtTotalSupply < currentDepositaryBalance) {\n            abt.mint(treasury, currentDepositaryBalance.sub(abtTotalSupply));\n            emit Rebalance();\n        }\n    }\n}\n"
    },
    "contracts/oracle/DepositaryOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./IDepositaryOracle.sol\";\n\ncontract DepositaryOracle is IDepositaryOracle, Ownable {\n    /// @dev Securities in depositary.\n    mapping(string => Security) private bonds;\n\n    /// @dev ISIN in depositary.\n    string[] private keys;\n\n    /// @notice The maximum number of security in this depositary.\n    function maxSize() public pure returns (uint256) {\n        return 50;\n    }\n\n    function put(\n        string calldata isin,\n        uint256 amount\n    ) external override onlyOwner {\n        require(keys.length < maxSize(), \"DepositaryOracle::put: too many securities\");\n\n        bonds[isin] = Security(isin, amount);\n        keys.push(isin);\n        emit Update(isin, amount);\n    }\n\n    function get(string calldata isin) external view override returns (Security memory) {\n        return bonds[isin];\n    }\n\n    function all() external view override returns (Security[] memory) {\n        DepositaryOracle.Security[] memory result = new DepositaryOracle.Security[](keys.length);\n\n        for (uint256 i = 0; i < keys.length; i++) {\n            result[i] = bonds[keys[i]];\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Budget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"./utils/OwnablePausable.sol\";\n\ncontract Budget is OwnablePausable {\n    using SafeMath for uint256;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Expenditure item.\n    struct Expenditure {\n        address recipient;\n        uint256 min;\n        uint256 target;\n    }\n\n    /// @notice Expenditure item to address.\n    mapping(address => Expenditure) public expenditures;\n\n    /// @dev Recipients addresses list.\n    EnumerableSet.AddressSet internal recipients;\n\n    /// @notice An event emitted when expenditure item changed.\n    event ExpenditureChanged(address recipient, uint256 min, uint256 target);\n\n    /// @notice An event emitted when expenditure item payed.\n    event Payed(address recipient, uint256 amount);\n\n    receive() external payable {}\n\n    /**\n     * @notice Change expenditure item.\n     * @param recipient Recipient address.\n     * @param min Minimal balance for payment.\n     * @param target Target balance.\n     */\n    function changeExpenditure(\n        address recipient,\n        uint256 min,\n        uint256 target\n    ) external onlyOwner {\n        require(min <= target, \"Budget::changeExpenditure: minimal balance should be less or equal target balance\");\n\n        expenditures[recipient] = Expenditure(recipient, min, target);\n        if (target > 0) {\n            recipients.add(recipient);\n        } else {\n            recipients.remove(recipient);\n        }\n        emit ExpenditureChanged(recipient, min, target);\n    }\n\n    /**\n     * @notice Transfer ETH to recipient.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transferETH(address payable recipient, uint256 amount) external onlyOwner returns (bool) {\n        recipient.transfer(amount);\n        return true;\n    }\n\n    /**\n     * @notice Return all recipients addresses.\n     * @return Recipients addresses.\n     */\n    function getRecipients() external view returns (address[] memory) {\n        address[] memory result = new address[](recipients.length());\n\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            result[i] = recipients.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Return balance deficit of recipient.\n     * @param recipient Target recipient.\n     * @return Balance deficit of recipient.\n     */\n    function deficitTo(address recipient) public view returns (uint256) {\n        require(recipients.contains(recipient), \"Budget::deficitTo: recipient not in expenditure item\");\n        if (recipient.balance > expenditures[recipient].min) return 0;\n\n        return expenditures[recipient].target.sub(recipient.balance);\n    }\n\n    /**\n     * @notice Return summary balance deficit of all recipients.\n     * @return Summary balance deficit of all recipients.\n     */\n    function deficit() public view returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            result = result.add(deficitTo(recipients.at(i)));\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Pay ETH to all recipients with balance deficit.\n     */\n    function pay() external {\n        for (uint256 i = 0; i < recipients.length(); i++) {\n            uint256 balance = address(this).balance;\n            address recipient = recipients.at(i);\n            uint256 amount = deficitTo(recipient);\n            if (amount == 0 || balance < amount) continue;\n\n            payable(recipient).transfer(amount);\n            emit Payed(recipient, amount);\n        }\n    }\n}\n"
    },
    "contracts/profit/Buyback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\n\ncontract Buyback is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Incoming token.\n    ERC20 public incoming;\n\n    /// @notice Outcoming token.\n    ERC20 public outcoming;\n\n    /// @notice Recipient address.\n    address public recipient;\n\n    /// @notice Uniswap router contract address.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @notice An event thats emitted when an incoming token transferred to recipient.\n    event Transfer(address recipient, uint256 amount);\n\n    /// @notice An event thats emitted when an recipient address changed.\n    event RecipientChanged(address newRecipient);\n\n    /// @notice An event thats emitted when an incoming token changed.\n    event IncomingChanged(address newIncoming);\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an buyback successed.\n    event BuybackSuccessed(uint256 incoming, uint256 outcoming);\n\n    /**\n     * @param _incoming Address of incoming token.\n     * @param _outcoming Address of outcoming token.\n     * @param _recipient Address of recipient outcoming token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     */\n    constructor(\n        address _incoming,\n        address _outcoming,\n        address _recipient,\n        address _uniswapRouter\n    ) public {\n        incoming = ERC20(_incoming);\n        outcoming = ERC20(_outcoming);\n        recipient = _recipient;\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Change recipient address.\n     * @param _recipient New recipient address.\n     */\n    function changeRecipient(address _recipient) external onlyOwner {\n        recipient = _recipient;\n        emit RecipientChanged(recipient);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Transfer incoming token to recipient.\n     * @param _recipient Address of recipient.\n     * @param amount Amount of transferred token.\n     */\n    function transfer(address _recipient, uint256 amount) public onlyOwner {\n        require(_recipient != address(0), \"Buyback::transfer: cannot transfer to the zero address\");\n\n        incoming.safeTransfer(_recipient, amount);\n        emit Transfer(_recipient, amount);\n    }\n\n    /**\n     * @notice Change incoming token address.\n     * @param _incoming New incoming token address.\n     * @param _recipient Address of recipient.\n     */\n    function changeIncoming(address _incoming, address _recipient) external onlyOwner {\n        require(address(incoming) != _incoming, \"Buyback::changeIncoming: duplicate incoming token address\");\n\n        uint256 balance = incoming.balanceOf(address(this));\n        if (balance > 0) {\n            transfer(_recipient, balance);\n        }\n        incoming = ERC20(_incoming);\n        emit IncomingChanged(_incoming);\n    }\n\n    /**\n     * @notice Make buyback attempt.\n     * @param amount Amount of tokens to buyback.\n     */\n    function buy(uint256 amount) external whenNotPaused {\n        if (amount > 0) {\n            incoming.safeTransferFrom(msg.sender, address(this), amount);\n        }\n\n        address[] memory path = new address[](2);\n        path[0] = address(incoming);\n        path[1] = address(outcoming);\n\n        uint256 amountIn = incoming.balanceOf(address(this));\n        require(amountIn > 0, \"Buyback::buy: incoming token balance is empty\");\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(amountIn, path);\n        require(amountsOut.length != 0, \"Buyback::buy: invalid amounts out length\");\n        uint256 amountOut = amountsOut[amountsOut.length - 1];\n        require(amountOut > 0, \"Buyback::buy: liquidity pool is empty\");\n\n        incoming.safeApprove(address(uniswapRouter), amountIn);\n        uniswapRouter.swapExactTokensForTokens(amountIn, amountOut, path, recipient, block.timestamp);\n        emit BuybackSuccessed(amountIn, amountOut);\n    }\n}\n"
    },
    "contracts/Timelock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint256;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint256 indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint256 value, string signature, bytes data, uint256 eta);\n\n    uint256 public constant GRACE_PERIOD = 14 days;\n    uint256 public constant MINIMUM_DELAY = 2 days;\n    uint256 public constant MAXIMUM_DELAY = 30 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint256 public delay;\n\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    constructor(address admin_, uint256 delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    receive() external payable {}\n\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function __transferAdmin(address _newAdmin) public {\n        require(msg.sender == admin, \"Timelock::__transferAdmin: caller is not the admin\");\n        admin = _newAdmin;\n\n        emit NewAdmin(admin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/GovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\ncontract GovernorAlpha {\n    /// @notice The name of this contract\n    string public constant name = \"Compound Governor Alpha\";\n\n    /// @notice The number of votes in support of a proposal required in order for a quorum to be reached and for a vote to succeed\n    function quorumVotes() public pure returns (uint256) {\n        return 400000e18;\n    } // 400,000 = 4% of Bond\n\n    /// @notice The number of votes required in order for a voter to become a proposer\n    function proposalThreshold() public pure returns (uint256) {\n        return 100000e18;\n    } // 100,000 = 1% of Bond\n\n    /// @notice The maximum number of actions that can be included in a proposal\n    function proposalMaxOperations() public pure returns (uint256) {\n        return 10;\n    } // 10 actions\n\n    /// @notice The delay before voting on a proposal may take place, once proposed\n    function votingDelay() public pure returns (uint256) {\n        return 1;\n    } // 1 block\n\n    /// @notice The duration of voting on a proposal, in blocks\n    function votingPeriod() public pure returns (uint256) {\n        return 17280;\n    } // ~3 days in blocks (assuming 15s blocks)\n\n    /// @notice The address of the Compound Protocol Timelock\n    TimelockInterface public timelock;\n\n    /// @notice The address of the Compound governance token\n    BondInterface public bond;\n\n    /// @notice The address of the Governor Guardian\n    address public guardian;\n\n    /// @notice The total number of proposals\n    uint256 public proposalCount;\n\n    struct Proposal {\n        // Unique id for looking up a proposal\n        uint256 id;\n        // Creator of the proposal\n        address proposer;\n        // The timestamp that the proposal will be available for execution, set once the vote succeeds\n        uint256 eta;\n        // the ordered list of target addresses for calls to be made\n        address[] targets;\n        // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n        uint256[] values;\n        // The ordered list of function signatures to be called\n        string[] signatures;\n        // The ordered list of calldata to be passed to each call\n        bytes[] calldatas;\n        // The block at which voting begins: holders must delegate their votes prior to this block\n        uint256 startBlock;\n        // The block at which voting ends: votes must be cast prior to this block\n        uint256 endBlock;\n        // Current number of votes in favor of this proposal\n        uint256 forVotes;\n        // Current number of votes in opposition to this proposal\n        uint256 againstVotes;\n        // Flag marking whether the proposal has been canceled\n        bool canceled;\n        // Flag marking whether the proposal has been executed\n        bool executed;\n        // Receipts of ballots for the entire set of voters\n        mapping(address => Receipt) receipts;\n    }\n\n    /// @notice Ballot receipt record for a voter\n    struct Receipt {\n        // Whether or not a vote has been cast\n        bool hasVoted;\n        // Whether or not the voter supports the proposal\n        bool support;\n        // The number of votes the voter had, which were cast\n        uint96 votes;\n    }\n\n    /// @notice Possible states that a proposal may be in\n    enum ProposalState {Pending, Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed}\n\n    /// @notice The official record of all proposals ever proposed\n    mapping(uint256 => Proposal) public proposals;\n\n    /// @notice The latest proposal for each proposer\n    mapping(address => uint256) public latestProposalIds;\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the ballot struct used by the contract\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,bool support)\");\n\n    /// @notice An event emitted when a new proposal is created\n    event ProposalCreated(uint256 id, address proposer, address[] targets, uint256[] values, string[] signatures, bytes[] calldatas, uint256 startBlock, uint256 endBlock, string description);\n\n    /// @notice An event emitted when a vote has been cast on a proposal\n    event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n    /// @notice An event emitted when a proposal has been canceled\n    event ProposalCanceled(uint256 id);\n\n    /// @notice An event emitted when a proposal has been queued in the Timelock\n    event ProposalQueued(uint256 id, uint256 eta);\n\n    /// @notice An event emitted when a proposal has been executed in the Timelock\n    event ProposalExecuted(uint256 id);\n\n    constructor(\n        address timelock_,\n        address bond_,\n        address guardian_\n    ) public {\n        timelock = TimelockInterface(timelock_);\n        bond = BondInterface(bond_);\n        guardian = guardian_;\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) public returns (uint256) {\n        require(bond.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay());\n        uint256 endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n            id: proposalCount,\n            proposer: msg.sender,\n            eta: 0,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            startBlock: startBlock,\n            endBlock: endBlock,\n            forVotes: 0,\n            againstVotes: 0,\n            canceled: false,\n            executed: false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }\n\n    function queue(uint256 proposalId) public {\n        require(state(proposalId) == ProposalState.Succeeded, \"GovernorAlpha::queue: proposal can only be queued if it is succeeded\");\n        Proposal storage proposal = proposals[proposalId];\n        uint256 eta = add256(block.timestamp, timelock.delay());\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            _queueOrRevert(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], eta);\n        }\n        proposal.eta = eta;\n        emit ProposalQueued(proposalId, eta);\n    }\n\n    function _queueOrRevert(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) internal {\n        require(!timelock.queuedTransactions(keccak256(abi.encode(target, value, signature, data, eta))), \"GovernorAlpha::_queueOrRevert: proposal action already queued at eta\");\n        timelock.queueTransaction(target, value, signature, data, eta);\n    }\n\n    function execute(uint256 proposalId) public payable {\n        require(state(proposalId) == ProposalState.Queued, \"GovernorAlpha::execute: proposal can only be executed if it is queued\");\n        Proposal storage proposal = proposals[proposalId];\n        proposal.executed = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.executeTransaction{value: proposal.values[i]}(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n        emit ProposalExecuted(proposalId);\n    }\n\n    function cancel(uint256 proposalId) public {\n        ProposalState state = state(proposalId);\n        require(state != ProposalState.Executed, \"GovernorAlpha::cancel: cannot cancel executed proposal\");\n\n        Proposal storage proposal = proposals[proposalId];\n        require(msg.sender == guardian || bond.getPriorVotes(proposal.proposer, sub256(block.number, 1)) < proposalThreshold(), \"GovernorAlpha::cancel: proposer above threshold\");\n\n        proposal.canceled = true;\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            timelock.cancelTransaction(proposal.targets[i], proposal.values[i], proposal.signatures[i], proposal.calldatas[i], proposal.eta);\n        }\n\n        emit ProposalCanceled(proposalId);\n    }\n\n    function getActions(uint256 proposalId)\n        public\n        view\n        returns (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas\n        )\n    {\n        Proposal storage p = proposals[proposalId];\n        return (p.targets, p.values, p.signatures, p.calldatas);\n    }\n\n    function getReceipt(uint256 proposalId, address voter) public view returns (Receipt memory) {\n        return proposals[proposalId].receipts[voter];\n    }\n\n    function state(uint256 proposalId) public view returns (ProposalState) {\n        require(proposalCount >= proposalId && proposalId > 0, \"GovernorAlpha::state: invalid proposal id\");\n        Proposal storage proposal = proposals[proposalId];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (block.number <= proposal.startBlock) {\n            return ProposalState.Pending;\n        } else if (block.number <= proposal.endBlock) {\n            return ProposalState.Active;\n        } else if (proposal.forVotes <= proposal.againstVotes || proposal.forVotes < quorumVotes()) {\n            return ProposalState.Defeated;\n        } else if (proposal.eta == 0) {\n            return ProposalState.Succeeded;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (block.timestamp >= add256(proposal.eta, timelock.GRACE_PERIOD())) {\n            return ProposalState.Expired;\n        } else {\n            return ProposalState.Queued;\n        }\n    }\n\n    function castVote(uint256 proposalId, bool support) public {\n        return _castVote(msg.sender, proposalId, support);\n    }\n\n    function castVoteBySig(\n        uint256 proposalId,\n        bool support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support));\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), \"GovernorAlpha::castVoteBySig: invalid signature\");\n        return _castVote(signatory, proposalId, support);\n    }\n\n    function _castVote(\n        address voter,\n        uint256 proposalId,\n        bool support\n    ) internal {\n        require(state(proposalId) == ProposalState.Active, \"GovernorAlpha::_castVote: voting is closed\");\n        Proposal storage proposal = proposals[proposalId];\n        Receipt storage receipt = proposal.receipts[voter];\n        require(receipt.hasVoted == false, \"GovernorAlpha::_castVote: voter already voted\");\n        uint96 votes = bond.getPriorVotes(voter, proposal.startBlock);\n\n        if (support) {\n            proposal.forVotes = add256(proposal.forVotes, votes);\n        } else {\n            proposal.againstVotes = add256(proposal.againstVotes, votes);\n        }\n\n        receipt.hasVoted = true;\n        receipt.support = support;\n        receipt.votes = votes;\n\n        emit VoteCast(voter, proposalId, support, votes);\n    }\n\n    function __acceptAdmin() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__acceptAdmin: sender must be gov guardian\");\n        timelock.acceptAdmin();\n    }\n\n    function __abdicate() public {\n        require(msg.sender == guardian, \"GovernorAlpha::__abdicate: sender must be gov guardian\");\n        guardian = address(0);\n    }\n\n    function __queueSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__queueSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.queueTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function __executeSetTimelockPendingAdmin(address newPendingAdmin, uint256 eta) public {\n        require(msg.sender == guardian, \"GovernorAlpha::__executeSetTimelockPendingAdmin: sender must be gov guardian\");\n        timelock.executeTransaction(address(timelock), 0, \"setPendingAdmin(address)\", abi.encode(newPendingAdmin), eta);\n    }\n\n    function add256(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"addition overflow\");\n        return c;\n    }\n\n    function sub256(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"subtraction underflow\");\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint256) {\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        return chainId;\n    }\n}\n\ninterface TimelockInterface {\n    function delay() external view returns (uint256);\n\n    function GRACE_PERIOD() external view returns (uint256);\n\n    function acceptAdmin() external;\n\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n\ninterface BondInterface {\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96);\n}\n"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ncontract Migrations {\n    address public owner;\n    uint256 public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint256 completed) public restricted {\n        last_completed_migration = completed;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}