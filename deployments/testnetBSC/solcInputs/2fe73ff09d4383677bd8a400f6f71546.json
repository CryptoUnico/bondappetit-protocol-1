{
  "language": "Solidity",
  "sources": {
    "contracts/depositary/BuybackDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"../Issuer.sol\";\nimport \"../Treasury.sol\";\n\ncontract BuybackDepositaryBalanceView is IDepositaryBalanceView, OwnablePausable {\n    using Math for uint256;\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    /// @notice Balance decimals.\n    uint256 public override decimals = 18;\n\n    /// @notice Address of product token.\n    ERC20 public product;\n\n    /// @notice Address of issuer contract.\n    Issuer public issuer;\n\n    /// @notice An event thats emitted when an issuer contract address changed.\n    event IssuerChanged(address newIssuer);\n\n    /// @notice An event thats emitted when an account buyback stable token.\n    event Buyback(address customer, uint256 amount, uint256 buy);\n\n    /**\n     * @param _issuer Issuer contract address.\n     * @param _product Product token address.\n     */\n    constructor(address _issuer, address _product) public {\n        issuer = Issuer(_issuer);\n        product = ERC20(_product);\n        require(product.decimals() <= decimals, \"BuybackDepositaryBalanceView::constructor: invalid decimals of product token\");\n    }\n\n    /**\n     * @notice Change issuer contract address.\n     * @param _issuer New issuer contract address.\n     */\n    function changeIssuer(address _issuer) external onlyOwner {\n        issuer = Issuer(_issuer);\n        emit IssuerChanged(_issuer);\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param token Transfered token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function _transfer(\n        ERC20 token,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(recipient != address(0), \"BuybackDepositaryBalanceView::_transfer: cannot transfer to the zero address\");\n\n        token.safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer product token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferProductToken(address recipient, uint256 amount) external onlyOwner {\n        _transfer(product, recipient, amount);\n    }\n\n    /**\n     * @notice Transfer stable token.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferStableToken(address recipient, uint256 amount) external onlyOwner {\n        _transfer(ERC20(issuer.stableToken()), recipient, amount);\n    }\n\n    /**\n     * @notice Buyback stable token.\n     * @param amount Amount of payment token.\n     */\n    function buy(uint256 amount) external whenNotPaused {\n        uint256 productAmount = amount.div(10**(decimals.sub(product.decimals())));\n        require(productAmount > 0, \"BuybackDepositaryBalanceView::buy: invalid product amount\");\n        require(productAmount >= product.balanceOf(address(this)), \"BuybackDepositaryBalanceView::buy: product amount exceeds balance\");\n\n        ERC20 stableToken = ERC20(issuer.stableToken());\n        stableToken.safeTransferFrom(_msgSender(), address(this), amount);\n        product.safeTransfer(_msgSender(), productAmount);\n\n        uint256 issuerInbalance = stableToken.totalSupply().sub(issuer.balance());\n        uint256 burningAmount = issuerInbalance.min(stableToken.balanceOf(address(this)));\n        if (burningAmount > 0) {\n            stableToken.safeTransfer(address(issuer), burningAmount);\n            issuer.rebalance();\n        }\n\n        emit Buyback(_msgSender(), amount, productAmount);\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 productBalance = product.balanceOf(address(this));\n\n        return productBalance.mul(10**(decimals.sub(product.decimals())));\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/utils/OwnablePausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ncontract OwnablePausable is Ownable, Pausable {\n    /// @notice Address that can pause a contract.\n    address public pauser;\n\n    /// @notice An event thats emitted when an pauser address changed.\n    event PauserChanged(address newPauser);\n\n    constructor() internal {\n        pauser = owner();\n    }\n\n    /**\n     * @notice Change pauser account.\n     * @param newPauser Address of new pauser account.\n     */\n    function changePauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n        emit PauserChanged(pauser);\n    }\n\n    /**\n     * @notice Triggers stopped state.\n     */\n    function pause() public virtual {\n        require(pauser == _msgSender() || owner() == _msgSender(), \"OwnablePausable::pause: only pauser and owner must pause contract\");\n        _pause();\n    }\n\n    /**\n     * @notice Returns to normal state.\n     */\n    function unpause() public virtual {\n        require(pauser == _msgSender() || owner() == _msgSender(), \"OwnablePausable::unpause: only pauser and owner must unpause contract\");\n        _unpause();\n    }\n}\n"
    },
    "contracts/depositary/IDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @title The Depositary Balance interface.\n */\ninterface IDepositaryBalanceView {\n    /**\n     * @notice Get decimals balance.\n     * @return Decimals balance.\n     */\n    function decimals() external view returns(uint256);\n\n    /**\n     * @notice Get balance of depositary.\n     * @return Balance of depositary.\n     */\n    function balance() external view returns(uint256);\n}"
    },
    "contracts/Issuer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/Math.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./depositary/AgregateDepositaryBalanceView.sol\";\nimport \"./StableToken.sol\";\n\ncontract Issuer is AgregateDepositaryBalanceView {\n    using Math for uint256;\n    using SafeMath for uint256;\n\n    /// @notice Stable token contract address.\n    StableToken public stableToken;\n\n    /// @notice Treasury contract address.\n    address public treasury;\n\n    /// @notice An event thats emitted when an Treasury contract transfered.\n    event TransferTreasury(address newTreasury);\n\n    /// @notice An event thats emitted when an stable token total supply rebalanced.\n    event Rebalance();\n\n    /**\n     * @param _stableToken Stable token contract address.\n     * @param _treasury Treasury contract address.\n     */\n    constructor(address _stableToken, address _treasury) public AgregateDepositaryBalanceView(StableToken(_stableToken).decimals(), 50) {\n        stableToken = StableToken(_stableToken);\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Transfer Treasury contract to new address.\n     * @param _treasury New address Treasury contract.\n     */\n    function changeTreasury(address _treasury) external onlyOwner {\n        treasury = _treasury;\n        emit TransferTreasury(treasury);\n    }\n\n    /**\n     * @notice Change owner of Stable token contract.\n     * @param _owner New owner address.\n     */\n    function changeStableTokenOwner(address _owner) external onlyOwner {\n        stableToken.transferOwnership(_owner);\n    }\n\n    /**\n     * @notice Rebalance stable token total supply by depositary balance. Mint stable token if depositary balance greater token total supply and burn otherwise.\n     */\n    function rebalance() external whenNotPaused {\n        uint256 currentDepositaryBalance = this.balance();\n        uint256 stableTokenTotalSupply = stableToken.totalSupply();\n\n        if (stableTokenTotalSupply > currentDepositaryBalance) {\n            uint256 burningBalance = stableToken.balanceOf(address(this));\n\n            if (burningBalance > 0) {\n                stableToken.burn(address(this), burningBalance.min(stableTokenTotalSupply.sub(currentDepositaryBalance)));\n                emit Rebalance();\n            }\n        } else if (stableTokenTotalSupply < currentDepositaryBalance) {\n            stableToken.mint(treasury, currentDepositaryBalance.sub(stableTokenTotalSupply));\n            emit Rebalance();\n        }\n    }\n}\n"
    },
    "contracts/Treasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/AccessControl.sol\";\n\ncontract Treasury is AccessControl {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    receive() external payable {}\n\n    /**\n     * @notice Transfer target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transfer(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyAllowed returns (bool) {\n        ERC20(token).safeTransfer(recipient, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer ETH to recipient.\n     * @param recipient Recipient.\n     * @param amount Transfer amount.\n     */\n    function transferETH(address payable recipient, uint256 amount) external onlyAllowed returns (bool) {\n        recipient.transfer(amount);\n        return true;\n    }\n\n    /**\n     * @notice Approve target token to recipient.\n     * @param token Target token.\n     * @param recipient Recipient.\n     * @param amount Approve amount.\n     */\n    function approve(\n        address token,\n        address recipient,\n        uint256 amount\n    ) external onlyAllowed returns (bool) {\n        uint256 allowance = ERC20(token).allowance(address(this), recipient);\n        if (allowance > 0) {\n            ERC20(token).safeApprove(recipient, 0);\n        }\n        ERC20(token).safeApprove(recipient, amount);\n        return true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies in extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return _functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        return _functionCallWithValue(target, data, value, errorMessage);\n    }\n\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\ncontract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor () internal {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!_paused, \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(_paused, \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "contracts/depositary/AgregateDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../utils/OwnablePausable.sol\";\nimport \"./IDepositaryBalanceView.sol\";\n\ncontract AgregateDepositaryBalanceView is IDepositaryBalanceView, OwnablePausable {\n    using SafeMath for uint256;\n\n    /// @notice The number of depositaries in agregate.\n    uint256 public maxSize;\n\n    /// @notice Decimals balance.\n    uint256 public override decimals;\n\n    /// @notice Depositaries in agregate.\n    IDepositaryBalanceView[] public depositaries;\n\n    /// @dev Depositaries index.\n    mapping(address => uint256) internal depositariesIndex;\n\n    /// @notice An event thats emitted when an new depositary added to agregate.\n    event DepositaryAdded(address depositary);\n\n    /// @notice An event thats emitted when an depositary removed from agregate.\n    event DepositaryRemoved(address depositary);\n\n    /**\n     * @param _decimals Decimals balance.\n     * @param _maxSize Max number depositaries in agregate.\n     */\n    constructor(uint256 _decimals, uint256 _maxSize) public {\n        decimals = _decimals;\n        maxSize = _maxSize;\n    }\n\n    /**\n     * @return Depositaries count of agregate.\n     */\n    function size() public view returns (uint256) {\n        return depositaries.length;\n    }\n\n    /**\n     * @notice Add depositary address to agregate.\n     * @param depositary Added depositary address.\n     */\n    function addDepositary(address depositary) external onlyOwner {\n        require(depositariesIndex[depositary] == 0, \"AgregateDepositaryBalanceView::addDepositary: depositary already added\");\n        require(size() < maxSize, \"AgregateDepositaryBalanceView::addDepositary: too many depositaries\");\n\n        depositaries.push(IDepositaryBalanceView(depositary));\n        depositariesIndex[depositary] = size();\n        emit DepositaryAdded(depositary);\n    }\n\n    /**\n     * @notice Removed depositary address from agregate.\n     * @param depositary Removed depositary address.\n     */\n    function removeDepositary(address depositary) external onlyOwner {\n        uint256 valueIndex = depositariesIndex[depositary];\n        require(valueIndex != 0, \"AgregateDepositaryBalanceView::removeDepositary: depositary already removed\");\n\n        uint256 toDeleteIndex = valueIndex.sub(1);\n        uint256 lastIndex = size().sub(1);\n        IDepositaryBalanceView lastValue = depositaries[lastIndex];\n        depositaries[toDeleteIndex] = lastValue;\n        depositariesIndex[address(lastValue)] = toDeleteIndex.add(1);\n        depositaries.pop();\n        delete depositariesIndex[depositary];\n\n        emit DepositaryRemoved(depositary);\n    }\n\n    /**\n     * @param depositary Target depositary address.\n     * @return True if target depositary is allowed.\n     */\n    function hasDepositary(address depositary) external view returns (bool) {\n        return depositariesIndex[depositary] != 0;\n    }\n\n    /**\n     * @return Allowed depositaries list.\n     */\n    function allowedDepositaries() external view returns (address[] memory) {\n        address[] memory result = new address[](size());\n\n        for (uint256 i = 0; i < size(); i++) {\n            result[i] = address(depositaries[i]);\n        }\n\n        return result;\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < size(); i++) {\n            uint256 depositaryBalance = depositaries[i].balance();\n            uint256 depositaryDecimals = depositaries[i].decimals();\n            uint256 decimalsPower = decimals.sub(depositaryDecimals);\n            result = result.add(depositaryBalance.mul(10**decimalsPower));\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/StableToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./utils/AccessControl.sol\";\n\ncontract StableToken is ERC20, AccessControl {\n    /**\n     * @param initialSupply Total supply.\n     */\n    constructor(uint256 initialSupply) public ERC20(\"Bond Appetite USD\", \"USDap\") {\n        _mint(_msgSender(), initialSupply);\n    }\n\n    /**\n     * @param account Recipient of created token.\n     * @param amount Amount of token to be created.\n     */\n    function mint(address account, uint256 amount) public onlyAllowed {\n        _mint(account, amount);\n    }\n\n    /**\n     * @param account Owner of removed token.\n     * @param amount Amount of token to be removed.\n     */\n    function burn(address account, uint256 amount) public onlyAllowed {\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\n\ncontract AccessControl is Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev Allowed address list.\n    EnumerableSet.AddressSet private allowed;\n\n    /// @notice An event emitted when address allowed.\n    event AccessAllowed(address member);\n\n    /// @notice An event emitted when address denied.\n    event AccessDenied(address member);\n\n    /**\n     * @notice Allow access.\n     * @param member Target address.\n     */\n    function allowAccess(address member) external onlyOwner {\n        require(!allowed.contains(member), \"AccessControl::allowAccess: member already allowed\");\n\n        allowed.add(member);\n        emit AccessAllowed(member);\n    }\n\n    /**\n     * @notice Deny access.\n     * @param member Target address.\n     */\n    function denyAccess(address member) external onlyOwner {\n        require(allowed.contains(member), \"AccessControl::denyAccess: member already denied\");\n\n        allowed.remove(member);\n        emit AccessDenied(member);\n    }\n\n    /**\n     * @return Allowed address list.\n     */\n    function accessList() external view returns (address[] memory) {\n        address[] memory result = new address[](allowed.length());\n\n        for (uint256 i = 0; i < allowed.length(); i++) {\n            result[i] = allowed.at(i);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Throws if called by any account other than allowed.\n     */\n    modifier onlyAllowed() {\n        require(allowed.contains(_msgSender()) || _msgSender() == owner(), \"AccessControl: caller is not allowed\");\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.0.0, only sets of type `address` (`AddressSet`) and `uint256`\n * (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping (bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\n\n            bytes32 lastvalue = set._values[lastIndex];\n\n            // Move the last value to the index where the value to delete is\n            set._values[toDeleteIndex] = lastvalue;\n            // Update the index for the moved value\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        require(set._values.length > index, \"EnumerableSet: index out of bounds\");\n        return set._values[index];\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(value)));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint256(_at(set._inner, index)));\n    }\n\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n   /**\n    * @dev Returns the value stored at position `index` in the set. O(1).\n    *\n    * Note that there are no guarantees on the ordering of values inside the\n    * array, and it may change when more values are added or removed.\n    *\n    * Requirements:\n    *\n    * - `index` must be strictly less than {length}.\n    */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n}\n"
    },
    "contracts/depositary/CurveDepositaryBalanceView.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/EnumerableSet.sol\";\nimport \"../curve/IRegistry.sol\";\nimport \"../uniswap/IUniswapV2Router02.sol\";\nimport \"./IDepositaryBalanceView.sol\";\nimport \"../curve/IPool.sol\";\nimport \"../curve/ILiquidityGauge.sol\";\nimport \"../curve/IMinter.sol\";\n\ncontract CurveDepositaryBalanceView is Ownable, IDepositaryBalanceView {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @notice Curve registry contract.\n    IRegistry public registry;\n\n    /// @notice Uniswap router contract.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @dev Invested pools.\n    EnumerableSet.AddressSet private pools;\n\n    /// @notice Balance decimals.\n    uint256 public override decimals = 18;\n\n    /// @dev Invested balances.\n    mapping(address => uint256) internal balances;\n\n    /// @notice An event thats emitted when an curve registry address changed.\n    event RegistryChanged(address registry);\n\n    /// @notice An event thats emitted when an uniswap router address changed.\n    event UniswapRouterChanged(address uniswapRouter);\n\n    /// @notice An event thats emitted when an invested token.\n    event Invested(address pool, address token, uint256 amount);\n\n    /// @notice An event thats emitted when an withdrawal token.\n    event Withdrawal(address token, uint256 amount, address recipient);\n\n    /// @notice An event thats emitted when an withdrawal proft token.\n    event Mint(address token, uint256 amount, address recipient);\n\n    /**\n     * @param _registry Curve registry contract address.\n     * @param _uniswapRouter Uniswap router contract address.\n     */\n    constructor(address _registry, address _uniswapRouter) public {\n        registry = IRegistry(_registry);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @param _registry New Curve registry contract address.\n     */\n    function changeRegistry(address _registry) external onlyOwner {\n        require(_registry != address(0), \"CurveDepositaryBalanceView::changeRegistry: invalid registry address\");\n\n        registry = IRegistry(_registry);\n        emit RegistryChanged(_registry);\n    }\n\n    /**\n     * @param _uniswapRouter New Uniswap router contract address.\n     */\n    function changeUniswap(address _uniswapRouter) external onlyOwner {\n        require(_uniswapRouter != address(0), \"CurveDepositaryBalanceView::changeUniswap: invalid uniswap address\");\n\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @param pool Target liquidity pool address.\n     * @return Liquidity pool token.\n     */\n    function _getPoolLiquidityToken(address pool) internal view returns (ERC20) {\n        address tokenAddress = registry.get_lp_token(pool);\n        require(tokenAddress != address(0), \"CurveDepositaryBalanceView::_getPoolLiquidityToken: liquidity token not found\");\n\n        return ERC20(tokenAddress);\n    }\n\n    /**\n     * @param pool Target liquidity pool address.\n     * @return Liquidity gauge.\n     */\n    function _getPoolLiquidityGauge(address pool) internal view returns (ILiquidityGauge) {\n        (address[10] memory gauges, ) = registry.get_gauges(pool);\n        require(gauges[0] != address(0), \"CurveDepositaryBalanceView::_getPoolLiquidityGauge: liquidity gauge not found\");\n\n        return ILiquidityGauge(gauges[0]);\n    }\n\n    /**\n     * @param pool Invested pool.\n     * @return Balance of invested pool.\n     */\n    function balanceOf(address pool) external view returns (uint256) {\n        return balances[pool];\n    }\n\n    /**\n     * @notice Lock all liquidity pool token in liquidity gauge.\n     * @param pool Target liquidity pool address.\n     */\n    function _lock(address pool) internal {\n        ILiquidityGauge gauge = _getPoolLiquidityGauge(pool);\n        ERC20 lpToken = _getPoolLiquidityToken(pool);\n        uint256 balance = lpToken.balanceOf(address(this));\n        if (balance == 0) return;\n\n        lpToken.safeApprove(address(gauge), 0);\n        lpToken.safeApprove(address(gauge), balance);\n        gauge.deposit(balance);\n    }\n\n    /**\n     * @notice Unlock all liquidity pool token from liquidity gauge.\n     * @param pool Target liquidity pool address.\n     */\n    function _unlock(address pool) internal {\n        ILiquidityGauge gauge = _getPoolLiquidityGauge(pool);\n        uint256 balance = ERC20(address(gauge)).balanceOf(address(this));\n\n        gauge.withdraw(balance);\n    }\n\n    /**\n     * @notice Mint CRV tokens and swap to target token.\n     * @param pool Target liquidity pool.\n     * @param toToken Target token.\n     * @param recipient Recipient.\n     */\n    function mint(\n        address pool,\n        address toToken,\n        address recipient\n    ) public onlyOwner {\n        require(toToken != address(0), \"CurveDepositaryBalanceView::mintCrv: invalid target token address\");\n\n        ILiquidityGauge gauge = _getPoolLiquidityGauge(pool);\n        IMinter minter = IMinter(gauge.minter());\n        minter.mint(address(gauge));\n\n        ERC20 crv = ERC20(minter.token());\n        uint256 crvBalance = crv.balanceOf(address(this));\n        if (crvBalance == 0) return;\n\n        if (toToken != address(crv)) {\n            address[] memory path = new address[](2);\n            path[0] = address(address(crv));\n            path[1] = address(toToken);\n\n            uint256[] memory amountsOut = uniswapRouter.getAmountsOut(crvBalance, path);\n            require(amountsOut.length == 2, \"CurveDepositaryBalanceView::mintCrv: invalid amount out\");\n            uint256 amountOut = amountsOut[amountsOut.length - 1];\n            require(amountOut > 0, \"CurveDepositaryBalanceView::mintCrv: liquidity pool is empty\");\n\n            crv.safeApprove(address(uniswapRouter), 0);\n            crv.safeApprove(address(uniswapRouter), crvBalance);\n            uint256[] memory profitAmount = uniswapRouter.swapExactTokensForTokens(crvBalance, amountOut, path, recipient, block.timestamp);\n\n            emit Mint(toToken, profitAmount[profitAmount.length - 1], recipient);\n        } else {\n            crv.safeTransfer(recipient, crvBalance);\n            emit Mint(address(crv), crvBalance, recipient);\n        }\n    }\n\n    /**\n     * @notice Invest token to Curve.\n     * @param pool Target liquidity pool.\n     * @param tokenIndex Invested token index in the pool. Target ERC20 token should be approved to contract before call.\n     * @param amount Amount of invested token.\n     */\n    function invest(\n        address pool,\n        uint256 tokenIndex,\n        uint256 amount\n    ) external onlyOwner {\n        require(amount > 0, \"CurveDepositaryBalanceView::invest: invalid amount\");\n        require(tokenIndex < 3, \"CurveDepositaryBalanceView::invest: invalid token index\");\n\n        address tokenAddress = IPool(pool).coins(tokenIndex);\n        require(tokenAddress != address(0), \"CurveDepositaryBalanceView::invest: invalid invest token\");\n\n        ERC20 token = ERC20(tokenAddress);\n        uint256 tokenDecimals = token.decimals();\n        require(tokenDecimals <= decimals, \"CurveDepositaryBalanceView::invest: invalid token decimals\");\n        token.safeTransferFrom(_msgSender(), address(this), amount);\n\n        balances[pool] = balances[pool].add(amount.mul(10**(decimals.sub(tokenDecimals)))); // Only stable token sum\n        pools.add(pool);\n\n        token.safeApprove(pool, 0);\n        token.safeApprove(pool, amount);\n        uint256[3] memory deposit;\n        deposit[tokenIndex] = amount;\n        IPool(pool).add_liquidity(deposit, 0);\n        _lock(pool);\n\n        emit Invested(pool, tokenAddress, amount);\n    }\n\n    /**\n     * @notice Withdraw invested token and reward.\n     * @param pool Target liquidity pool.\n     * @param tokenIndex Invested token index in the pool.\n     * @param recipient Recipient of invested token.\n     */\n    function withdraw(\n        address pool,\n        uint256 tokenIndex,\n        address recipient\n    ) external onlyOwner {\n        require(tokenIndex < 3, \"CurveDepositaryBalanceView::invest: invalid token index\");\n\n        address tokenAddress = IPool(pool).coins(tokenIndex);\n        require(tokenAddress != address(0), \"CurveDepositaryBalanceView::withdraw: invalid withdraw token\");\n        ERC20 lpToken = _getPoolLiquidityToken(pool);\n\n        balances[pool] = 0;\n        pools.remove(pool);\n\n        _unlock(pool);\n        uint256 lpBalance = lpToken.balanceOf(address(this));\n        IPool(pool).remove_liquidity_one_coin(lpBalance, int128(tokenIndex), 0);\n\n        ERC20 token = ERC20(tokenAddress);\n        uint256 balance = token.balanceOf(address(this));\n        token.safeTransfer(recipient, balance);\n\n        emit Withdrawal(tokenAddress, balance, recipient);\n    }\n\n    /**\n     * @return Invested liquidity pools.\n     */\n    function investedPools() external view returns (address[] memory) {\n        address[] memory result = new address[](pools.length());\n\n        for (uint256 i = 0; i < pools.length(); i++) {\n            result[i] = pools.at(i);\n        }\n\n        return result;\n    }\n\n    function balance() external view override returns (uint256) {\n        uint256 result;\n\n        for (uint256 i = 0; i < pools.length(); i++) {\n            address pool = pools.at(i);\n            result = result.add(balances[pool]);\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/curve/IRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IRegistry {\n    function get_lp_token(address pool) external view returns (address);\n\n    function get_gauges(address pool) external view returns (address[10] memory, int128[10] memory);\n}\n"
    },
    "contracts/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IUniswapV2Router02 {\n    function factory() external pure returns (address);\n\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/curve/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IPool {\n    function coins(uint256 i) external view returns (address);\n\n    function add_liquidity(uint256[3] memory _deposit_amounts, uint256 _min_mint_amount) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _burn_amount,\n        int128 i,\n        uint256 _min_received\n    ) external;\n}\n"
    },
    "contracts/curve/ILiquidityGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface ILiquidityGauge {\n    function minter() external view returns (address);\n\n    function crv_token() external view returns (address);\n\n    function claimable_tokens(address recipient) external returns (uint256);\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/curve/IMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IMinter {\n    function token() external view returns (address);\n\n    function minted(address recipient, address gauge) external view returns (uint256);\n\n    function mint(address gauge_addr) external;\n}\n"
    },
    "contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./utils/OwnablePausable.sol\";\nimport \"./uniswap/IUniswapV2Router02.sol\";\nimport \"./chainlink/CrossPriceFeed.sol\";\n\ncontract Market is OwnablePausable {\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n    using CrossPriceFeed for address[];\n\n    uint8 public constant PRICE_DECIMALS = 6;\n\n    uint256 public constant REWARD_DECIMALS = 12;\n\n    /// @notice Address of cumulative token.\n    ERC20 public cumulative;\n\n    /// @dev Addresses of cumulative token price feed chain.\n    address[] internal cumulativePriceFeed;\n\n    /// @notice Address of product token contract.\n    ERC20 public productToken;\n\n    /// @notice Address of reward token contract.\n    ERC20 public rewardToken;\n\n    /// @dev Address of UniswapV2Router.\n    IUniswapV2Router02 public uniswapRouter;\n\n    /// @dev Allowed tokens symbols list.\n    mapping(address => address[]) internal allowedTokens;\n\n    /// @notice An event thats emitted when an uniswap router contract address changed.\n    event UniswapRouterChanged(address newUniswapRouter);\n\n    /// @notice An event thats emitted when an cumulative token changed.\n    event CumulativeChanged(address newToken, address[] priceFeed);\n\n    /// @notice An event thats emitted when an token allowed.\n    event TokenAllowed(address token, address[] priceFeed);\n\n    /// @notice An event thats emitted when an token denied.\n    event TokenDenied(address token);\n\n    /// @notice An event thats emitted when an account buyed token.\n    event Buy(address customer, address token, uint256 amount, uint256 buy, uint256 reward);\n\n    /// @notice An event thats emitted when an cumulative token withdrawal.\n    event Withdrawal(address recipient, address token, uint256 amount);\n\n    /**\n     * @param _cumulative Address of cumulative token.\n     * @param _productToken Address of product token.\n     * @param _rewardToken Address of reward token.\n     * @param _uniswapRouter Address of Uniswap router contract.\n     * @param _cumulativePriceFeed Price feeds chain of cumulative token.\n     */\n    constructor(\n        address _cumulative,\n        address _productToken,\n        address _rewardToken,\n        address _uniswapRouter,\n        address[] memory _cumulativePriceFeed\n    ) public {\n        cumulative = ERC20(_cumulative);\n        cumulativePriceFeed = _cumulativePriceFeed;\n        productToken = ERC20(_productToken);\n        rewardToken = ERC20(_rewardToken);\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed uniswap router contract address.\n     * @param _uniswapRouter Address new uniswap router contract.\n     */\n    function changeUniswapRouter(address _uniswapRouter) external onlyOwner {\n        uniswapRouter = IUniswapV2Router02(_uniswapRouter);\n        emit UniswapRouterChanged(_uniswapRouter);\n    }\n\n    /**\n     * @notice Changed cumulative token address.\n     * @param newToken Address new cumulative token.\n     * @param newCumulativePriceFeed Address new price oracle contract.\n     * @param recipient Address of recipient for withdraw current cumulative balance.\n     */\n    function changeCumulativeToken(\n        address newToken,\n        address[] memory newCumulativePriceFeed,\n        address recipient\n    ) external onlyOwner {\n        withdraw(recipient);\n        cumulative = ERC20(newToken);\n        cumulativePriceFeed = newCumulativePriceFeed;\n        emit CumulativeChanged(newToken, cumulativePriceFeed);\n    }\n\n    /**\n     * @notice Add token to tokens white list.\n     * @param token Allowable token.\n     * @param priceFeed Price feed chain.\n     */\n    function allowToken(address token, address[] memory priceFeed) external onlyOwner {\n        allowedTokens[token] = priceFeed;\n        emit TokenAllowed(token, priceFeed);\n    }\n\n    /**\n     * @notice Remove token from tokens white list.\n     * @param token Denied token.\n     */\n    function denyToken(address token) external onlyOwner {\n        allowedTokens[token] = new address[](0);\n        emit TokenDenied(token);\n    }\n\n    /**\n     * @param token Target token.\n     * @return Is target token allowed.\n     */\n    function isAllowedToken(address token) public view returns (bool) {\n        return allowedTokens[token].length != 0;\n    }\n\n    /**\n     * @dev Transfer token to recipient.\n     * @param from Address of transfered token contract.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transfer(\n        ERC20 from,\n        address recipient,\n        uint256 amount\n    ) internal {\n        require(recipient != address(0), \"Market::transfer: cannot transfer to the zero address\");\n\n        uint256 currentBalance = from.balanceOf(address(this));\n        require(amount <= currentBalance, \"Market::transfer: not enough tokens\");\n\n        from.safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Transfer product token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferProductToken(address recipient, uint256 amount) external onlyOwner {\n        transfer(productToken, recipient, amount);\n    }\n\n    /**\n     * @notice Transfer reward token to recipient.\n     * @param recipient Address of recipient.\n     * @param amount Amount of transfered token.\n     */\n    function transferRewardToken(address recipient, uint256 amount) external onlyOwner {\n        transfer(rewardToken, recipient, amount);\n    }\n\n    /**\n     * @param token Target token.\n     * @return Price token at USD.\n     */\n    function _priceUSD(address token) public view returns (uint256) {\n        address[] memory priceFeed = token == address(cumulative) ? cumulativePriceFeed : allowedTokens[token];\n        int256 price = priceFeed.getAmountOut(int128(10)**PRICE_DECIMALS);\n        if (price <= 0) return 0;\n\n        return uint256(price);\n    }\n\n    /**\n     * @notice Get token price.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return product Amount of product token.\n     * @return reward Amount of reward token.\n     */\n    function price(address currency, uint256 payment) public view returns (uint256 product, uint256 reward) {\n        require(isAllowedToken(currency), \"Market::price: currency not allowed\");\n\n        uint256 tokenDecimals = ERC20(currency).decimals();\n        uint256 productDecimals = productToken.decimals();\n        uint256 tokenPrice = _priceUSD(currency);\n        uint256 cumulativePrice = _priceUSD(address(cumulative));\n\n        if (cumulativePrice != 0) {\n            product = payment.mul(10**productDecimals.sub(tokenDecimals));\n            if (address(productToken) != currency) {\n                product = tokenPrice.mul(uint256(int128(10)**PRICE_DECIMALS)).div(cumulativePrice).mul(payment).div(uint256(int128(10)**PRICE_DECIMALS)).mul(10**productDecimals.sub(tokenDecimals));\n            }\n        }\n\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        if (productTokenBalance > 0) {\n            uint256 rewardTokenBalance = rewardToken.balanceOf(address(this));\n            reward = product.mul(10**REWARD_DECIMALS).div(productTokenBalance).mul(rewardTokenBalance).div(10**REWARD_DECIMALS);\n        }\n    }\n\n    /**\n     * @param currency Currency token.\n     * @return Pools for each consecutive pair of addresses must exist and have liquidity\n     */\n    function _path(address currency) internal view returns (address[] memory) {\n        address weth = uniswapRouter.WETH();\n        if (weth == currency) {\n            address[] memory path = new address[](2);\n            path[0] = currency;\n            path[1] = address(cumulative);\n            return path;\n        }\n\n        address[] memory path = new address[](3);\n        path[0] = currency;\n        path[1] = weth;\n        path[2] = address(cumulative);\n        return path;\n    }\n\n    /**\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return Amount cumulative token after swap.\n     */\n    function _amountOut(address currency, uint256 payment) internal view returns (uint256) {\n        uint256[] memory amountsOut = uniswapRouter.getAmountsOut(payment, _path(currency));\n        require(amountsOut.length != 0, \"Market::_amountOut: invalid amounts out length\");\n\n        return amountsOut[amountsOut.length - 1];\n    }\n\n    /**\n     * @notice Buy token with ERC20.\n     * @param currency Currency token.\n     * @param payment Amount of payment.\n     * @return True if success.\n     */\n    function buy(address currency, uint256 payment) external whenNotPaused returns (bool) {\n        (uint256 product, uint256 reward) = price(currency, payment);\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        require(productTokenBalance > 0 && product <= productTokenBalance, \"Market::buy: exceeds balance\");\n\n        ERC20(currency).safeTransferFrom(_msgSender(), address(this), payment);\n\n        if (currency != address(cumulative)) {\n            uint256 amountOut = _amountOut(currency, payment);\n            require(amountOut != 0, \"Market::buy: liquidity pool is empty\");\n\n            ERC20(currency).safeApprove(address(uniswapRouter), 0);\n            ERC20(currency).safeApprove(address(uniswapRouter), payment);\n            uniswapRouter.swapExactTokensForTokens(payment, amountOut, _path(currency), address(this), block.timestamp);\n        }\n\n        productToken.safeTransfer(_msgSender(), product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(_msgSender(), reward);\n        }\n        emit Buy(_msgSender(), currency, payment, product, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Buy token with ETH.\n     * @return True if success.\n     */\n    function buyFromETH() external payable whenNotPaused returns (bool) {\n        address currency = uniswapRouter.WETH();\n        uint256 payment = msg.value;\n\n        (uint256 product, uint256 reward) = price(currency, payment);\n        uint256 productTokenBalance = productToken.balanceOf(address(this));\n        require(product <= productTokenBalance, \"Market::buyFromETH: balance is empty\");\n\n        if (currency != address(cumulative)) {\n            uint256 amountOut = _amountOut(currency, payment);\n            require(amountOut != 0, \"Market::buyFromETH: liquidity pool is empty\");\n\n            uniswapRouter.swapExactETHForTokens{value: payment}(amountOut, _path(currency), address(this), block.timestamp);\n        }\n\n        productToken.safeTransfer(_msgSender(), product);\n        if (reward > 0) {\n            rewardToken.safeTransfer(_msgSender(), reward);\n        }\n        emit Buy(_msgSender(), currency, payment, product, reward);\n\n        return true;\n    }\n\n    /**\n     * @notice Withdraw cumulative token to address.\n     * @param recipient Recipient of token.\n     */\n    function withdraw(address recipient) public onlyOwner {\n        require(recipient != address(0), \"Market::withdraw: cannot transfer to the zero address\");\n\n        uint256 balance = cumulative.balanceOf(address(this));\n        cumulative.safeTransfer(recipient, balance);\n\n        emit Withdrawal(recipient, address(cumulative), balance);\n    }\n}\n"
    },
    "contracts/chainlink/CrossPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"./IPriceFeed.sol\";\n\nlibrary CrossPriceFeed {\n    using SignedSafeMath for int256;\n\n    /**\n     * @param path Price feeds chain.\n     * @param amountIn Input amount.\n     * @return amounts Output amount of all price feeds.\n     */\n    function getAmountsOut(address[] memory path, int256 amountIn) internal view returns (int256[] memory amounts) {\n        require(path.length > 0, \"ChainlinkCrossPriceFeed: invalid path\");\n\n        amounts = new int256[](path.length + 1);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length; i++) {\n            IPriceFeed priceFeed = IPriceFeed(path[i]);\n            uint8 decimals = priceFeed.decimals();\n            (, int256 price, , , ) = priceFeed.latestRoundData();\n\n            amounts[i + 1] = amounts[i].mul(price).div(int128(10)**decimals);\n        }\n    }\n\n    /**\n     * @param path Price feeds chain.\n     * @param amountIn Input amount.\n     * @return Output amount of latest price feed.\n     */\n    function getAmountOut(address[] memory path, int256 amountIn) internal view returns (int256) {\n        return getAmountsOut(path, amountIn)[path.length];\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/chainlink/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\ninterface IPriceFeed {\n    function decimals() external view returns (uint8);\n\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function version() external view returns (uint256);\n}"
    },
    "contracts/chainlink/PriceFeedMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\nimport \"./IPriceFeed.sol\";\n\ncontract PriceFeedMock is IPriceFeed {\n    uint8 override public decimals;\n\n    uint256 override public version;\n\n    struct Round {\n        uint80 roundId;\n        int256 answer;\n        uint256 startedAt;\n        uint256 updatedAt;\n        uint80 answeredInRound;\n    }\n\n    mapping(uint80 => Round) internal _rounds;\n\n    uint80 public latestRoundId;\n\n    constructor(uint8 _decimals, uint256 _version) public {\n        decimals = _decimals;\n        version = _version;\n    }\n\n    function addRound(\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) public {\n        _rounds[++latestRoundId] = Round(roundId, answer, startedAt, updatedAt, answeredInRound);\n    }\n\n    function getRoundData(uint80 _roundId)\n        override\n        public\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        roundId = _rounds[_roundId].roundId;\n        answer = _rounds[_roundId].answer;\n        startedAt = _rounds[_roundId].startedAt;\n        updatedAt = _rounds[_roundId].updatedAt;\n        answeredInRound = _rounds[_roundId].answeredInRound;\n    }\n\n    function latestRoundData()\n        override\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        )\n    {\n        return getRoundData(latestRoundId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}